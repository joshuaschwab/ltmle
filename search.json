[{"path":"http://joshuaschwab.github.io/ltmle/articles/a01_overview.html","id":"ltmle","dir":"Articles","previous_headings":"","what":"ltmle()","title":"ltmle Package Overview","text":"data Anodes Ynodes abar Cnodes Lnodes SL.library survivalOutcome gbounds Yrange stratify SL.cvControl estimate.time gcomp iptw.variance.method observation.weights id Qform gform rule deterministic.g.function deterministic.Q.function","code":"ltmle(data, Anodes, Cnodes = NULL, Lnodes = NULL, Ynodes,   survivalOutcome = NULL, Qform = NULL, gform = NULL, abar,   rule = NULL, gbounds = c(0.01, 1), Yrange = NULL,   deterministic.g.function = NULL, stratify = FALSE,   SL.library = \"glm\", SL.cvControl = list(), estimate.time = TRUE,   gcomp = FALSE, iptw.only = FALSE, deterministic.Q.function = NULL,   variance.method = \"tmle\", observation.weights = NULL, id = NULL)"},{"path":"http://joshuaschwab.github.io/ltmle/articles/a01_overview.html","id":"ltmlemsm","dir":"Articles","previous_headings":"","what":"ltmleMSM()","title":"ltmle Package Overview","text":"data Anodes Ynodes regimes working.msm summary.measures Cnodes Lnodes SL.library survivalOutcome final.Ynodes msm.weights gbounds Yrange stratify SL.cvControl estimate.time gcomp iptw.variance.method observation.weights id Qform gform rule deterministic.g.function deterministic.Q.function","code":"ltmleMSM(data, Anodes, Cnodes = NULL, Lnodes = NULL, Ynodes,   survivalOutcome = NULL, Qform = NULL, gform = NULL,   gbounds = c(0.01, 1), Yrange = NULL,   deterministic.g.function = NULL, SL.library = \"glm\",   SL.cvControl = list(), regimes, working.msm, summary.measures,   final.Ynodes = NULL, stratify = FALSE, msm.weights = \"empirical\",   estimate.time = TRUE, gcomp = FALSE, iptw.only = FALSE,   deterministic.Q.function = NULL, variance.method = \"tmle\",   observation.weights = NULL, id = NULL)"},{"path":"http://joshuaschwab.github.io/ltmle/articles/a02_intro.html","id":"minimal-example","dir":"Articles","previous_headings":"","what":"Minimal Example","title":"Introduction to ltmle","text":"Consider observed data time ordering W -> -> Y. W continuous baseline covariate affects Y. binary treatment variable affects Y. Y binary outcome variable. W ~ N(0, 1) ~ binomial P(= 1) = expit(W) Y ~ binomial P(Y = 1) = expit(W + ) \\(expit(z) = \\frac{1}{1 + e^{-z}}\\) want know \\(E[Y_1]\\) expected value Y, intervening set 1. try use simple mean Y mean Y = 1, biased. Now use ltmle(). ’re using simulated data, can calculate true value \\(E[Y_1]\\)","code":"rexpit <- function(x) rbinom(n=length(x), size=1, prob=plogis(x)) n <- 10000 W <- rnorm(n) A <- rexpit(W) Y <- rexpit(W + A) data <- data.frame(W, A, Y) head(data) #>            W A Y #> 1 -0.4279303 0 0 #> 2  1.4574234 1 0 #> 3  1.0707788 0 0 #> 4  0.1043061 0 1 #> 5 -1.0561932 0 1 #> 6  1.4509283 1 1 mean(Y) #> [1] 0.5933 mean(Y[A == 1]) #> [1] 0.7755952 result <- ltmle(data, Anodes = \"A\", Ynodes = \"Y\", abar = 1) #> Qform not specified, using defaults: #> formula for Y: #> Q.kplus1 ~ W + A #>  #> gform not specified, using defaults: #> formula for A: #> A ~ W #>  #> Estimate of time to completion: < 1 minute result #> Call: #> ltmle(data = data, Anodes = \"A\", Ynodes = \"Y\", abar = 1) #>  #> TMLE Estimate:  0.7038161 n.large <- 1e6 W <- rnorm(n.large) A <- 1 Y <- rexpit(W + A) mean(Y) #> [1] 0.697189"},{"path":"http://joshuaschwab.github.io/ltmle/articles/a02_intro.html","id":"single-time-point","dir":"Articles","previous_headings":"","what":"Single time point","title":"Introduction to ltmle","text":"Time ordering data W1 -> W2 -> W3 -> -> Y True value \\(E[Y_1]\\) approximately 0.5939. SuperLearner semiparametric estimation using parents regressors TMLE estimate: IPTW estimate: SuperLearner semiparametric estimation using correctly specified regressors. passes W1^2, W2, W3, W3:columns matrix X SuperLearner Q regression W1 W3 columns matrix X SuperLearner g regression. glm using correctly specified Qform gform Get summary measures (additive treatment effect, odds ratio, relative risk) abar=1 vs abar=0","code":"n <- 1000 W1 <- rnorm(n) W2 <- rbinom(n, size=1, prob=0.3)    W3 <- rnorm(n) A <- rexpit(-1 + 2 * W1 + W3) Y <- rexpit(-0.5 + 2 * W1^2 + 0.5 * W2 - 0.5 * A + 0.2 * W3 * A - 1.1 * W3) data <- data.frame(W1, W2, W3, A, Y) result <- ltmle(data, Anodes=\"A\", Lnodes=NULL, Ynodes=\"Y\", abar=1, SL.library=\"default\") #> Loading required namespace: SuperLearner #> Qform not specified, using defaults: #> formula for Y: #> Q.kplus1 ~ W1 + W2 + W3 + A #>  #> gform not specified, using defaults: #> formula for A: #> A ~ W1 + W2 + W3 #>  #> Loading required package: nnls #> Loading required namespace: arm #> Estimate of time to completion: 1 minute summary(result) #> Estimator:  tmle  #> Call: #> ltmle(data = data, Anodes = \"A\", Lnodes = NULL, Ynodes = \"Y\",  #>     abar = 1, SL.library = \"default\") #>  #>    Parameter Estimate:  0.52314  #>     Estimated Std Err:  0.052142  #>               p-value:  <2e-16  #>     95% Conf Interval: (0.42095, 0.62534) summary(result, estimator=\"iptw\") #> Estimator:  iptw  #> Call: #> ltmle(data = data, Anodes = \"A\", Lnodes = NULL, Ynodes = \"Y\",  #>     abar = 1, SL.library = \"default\") #>  #>    Parameter Estimate:  0.50498  #>     Estimated Std Err:  0.036893  #>               p-value:  <2e-16  #>     95% Conf Interval: (0.43267, 0.57729) result <- ltmle(data, Anodes=\"A\", Lnodes=NULL, Ynodes=\"Y\",                  Qform=c(Y=\"Q.kplus1 ~ I(W1^2) + W2 + W3*A\"),                  gform=\"A ~ W1 + W3\", abar=1, SL.library=\"default\") #> Estimate of time to completion: 1 minute summary(result) #> Estimator:  tmle  #> Call: #> ltmle(data = data, Anodes = \"A\", Lnodes = NULL, Ynodes = \"Y\",  #>     Qform = c(Y = \"Q.kplus1 ~ I(W1^2) + W2 + W3*A\"), gform = \"A ~ W1 + W3\",  #>     abar = 1, SL.library = \"default\") #>  #>    Parameter Estimate:  0.55156  #>     Estimated Std Err:  0.039658  #>               p-value:  <2e-16  #>     95% Conf Interval: (0.47383, 0.62929) result <- ltmle(data, Anodes=\"A\", Lnodes=NULL, Ynodes=\"Y\",   Qform=c(Y=\"Q.kplus1 ~ I(W1^2) + W2 + W3*A\"), gform=\"A ~ W1 + W3\",   abar=1, SL.library=NULL) #> Estimate of time to completion: < 1 minute summary(result) #> Estimator:  tmle  #> Call: #> ltmle(data = data, Anodes = \"A\", Lnodes = NULL, Ynodes = \"Y\",  #>     Qform = c(Y = \"Q.kplus1 ~ I(W1^2) + W2 + W3*A\"), gform = \"A ~ W1 + W3\",  #>     abar = 1, SL.library = NULL) #>  #>    Parameter Estimate:  0.55102  #>     Estimated Std Err:  0.040134  #>               p-value:  <2e-16  #>     95% Conf Interval: (0.47236, 0.62969) result <- ltmle(data, Anodes=\"A\", Lnodes=NULL, Ynodes=\"Y\",                        abar=list(1, 0), SL.library=\"default\") #> Qform not specified, using defaults: #> formula for Y: #> Q.kplus1 ~ W1 + W2 + W3 + A #>  #> gform not specified, using defaults: #> formula for A: #> A ~ W1 + W2 + W3 #>  #> Estimate of time to completion: 1 minute summary(result) #> Estimator:  tmle  #> Call: #> ltmle(data = data, Anodes = \"A\", Lnodes = NULL, Ynodes = \"Y\",  #>     abar = list(1, 0), SL.library = \"default\") #>  #> Treatment Estimate: #>    Parameter Estimate:  0.523  #>     Estimated Std Err:  0.052158  #>               p-value:  <2e-16  #>     95% Conf Interval: (0.42077, 0.62522)  #>  #> Control Estimate: #>    Parameter Estimate:  0.66623  #>     Estimated Std Err:  0.03157  #>               p-value:  <2e-16  #>     95% Conf Interval: (0.60436, 0.72811)  #>  #> Additive Treatment Effect: #>    Parameter Estimate:  -0.14324  #>     Estimated Std Err:  0.06053  #>               p-value:  0.017962  #>     95% Conf Interval: (-0.26187, -0.024602)  #>  #> Relative Risk: #>    Parameter Estimate:  0.785  #>   Est Std Err log(RR):  0.10987  #>               p-value:  0.027579  #>     95% Conf Interval: (0.63292, 0.97363)  #>  #> Odds Ratio: #>    Parameter Estimate:  0.54928  #>   Est Std Err log(OR):  0.25058  #>               p-value:  0.0168  #>     95% Conf Interval: (0.33612, 0.89761)"},{"path":"http://joshuaschwab.github.io/ltmle/articles/a02_intro.html","id":"censoring","dir":"Articles","previous_headings":"","what":"Censoring","title":"Introduction to ltmle","text":"Time ordering data W -> C -> Y. C censoring node. parameter interest Y, intervening set C uncensored. Censoring nodes similar treatment nodes. main difference censoring, data expected NA. assumed parameter interest always intervenes set censoring nodes uncensored, specified abar. g Q regressions always stratify censoring nodes, whereas g Q regressions can either stratify pool treatment nodes (using stratify argument.) Censoring nodes data factors two levels - “censored” “uncensored”. utility function BinaryToCensoring can used facilitate . naive estimate biased (true value 0.5):","code":"n <- 100000 W <- rnorm(n) C <- BinaryToCensoring(is.censored = rexpit(W)) summary(C) #>   censored uncensored  #>      49602      50398 Y <- rep(NA, n) Y[C == \"uncensored\"] <- rexpit(W[C == \"uncensored\"]) data <- data.frame(W, C, Y) head(data, 20) #>               W          C  Y #> 1   0.262484210   censored NA #> 2   0.477787079   censored NA #> 3  -0.714712259 uncensored  1 #> 4  -1.238919138 uncensored  0 #> 5  -2.139408634 uncensored  0 #> 6   0.042832534   censored NA #> 7  -0.463368027 uncensored  1 #> 8   0.831059210 uncensored  1 #> 9  -0.934787551   censored NA #> 10  0.099089489 uncensored  1 #> 11 -0.006446757   censored NA #> 12 -0.671929261 uncensored  1 #> 13 -0.238794717 uncensored  0 #> 14  0.846808649 uncensored  0 #> 15  0.022652476 uncensored  0 #> 16 -0.871430896 uncensored  0 #> 17  0.326610513   censored NA #> 18 -2.281704667 uncensored  0 #> 19 -0.038487995 uncensored  0 #> 20  0.074187970 uncensored  1 result <- ltmle(data, Anodes = NULL, Cnodes = \"C\", Ynodes = \"Y\", abar = NULL) #> Qform not specified, using defaults: #> formula for Y: #> Q.kplus1 ~ W #>  #> gform not specified, using defaults: #> formula for C: #> C ~ W #>  #> Estimate of time to completion: < 1 minute summary(result) #> Estimator:  tmle  #> Call: #> ltmle(data = data, Anodes = NULL, Cnodes = \"C\", Ynodes = \"Y\",  #>     abar = NULL) #>  #>    Parameter Estimate:  0.50302  #>     Estimated Std Err:  0.0023113  #>               p-value:  <2e-16  #>     95% Conf Interval: (0.49849, 0.50755) mean(data$Y) #> [1] NA mean(data$Y, na.rm = T) #> [1] 0.4168023"},{"path":"http://joshuaschwab.github.io/ltmle/articles/a02_intro.html","id":"longitudinal-data","dir":"Articles","previous_headings":"","what":"Longitudinal data","title":"Introduction to ltmle","text":"Time ordering data W -> A1 -> L -> A2 -> Y. L time-dependent covariate occurs treatment (censoring) variable, A1. indicate using Lnodes argument. Treatment regime interest: set A1 0, set A2 0","code":"n <- 1000 W <- rnorm(n) A1 <- rexpit(W) L <- 0.3 * W + 0.2 * A1 + rnorm(n) A2 <- rexpit(W + A1 + L) Y <- rexpit(W - 0.6 * A1 + L - 0.8 * A2) data <- data.frame(W, A1, L, A2, Y) head(data) #>            W A1           L A2 Y #> 1 -0.1021195  0 -0.82035274  0 1 #> 2  1.0973443  1 -0.01933638  1 0 #> 3 -0.9428153  1  0.77249983  0 0 #> 4  0.8548010  1  0.24841621  1 0 #> 5 -0.1048682  0  0.57014463  1 0 #> 6 -0.6193304  0 -1.02495002  1 0 ltmle(data, Anodes=c(\"A1\", \"A2\"), Lnodes=\"L\", Ynodes=\"Y\", abar=c(0, 0)) #> Qform not specified, using defaults: #> formula for L: #> Q.kplus1 ~ W + A1 #> formula for Y: #> Q.kplus1 ~ W + A1 + L + A2 #>  #> gform not specified, using defaults: #> formula for A1: #> A1 ~ W #> formula for A2: #> A2 ~ W + A1 + L #>  #> Estimate of time to completion: < 1 minute #> Call: #> ltmle(data = data, Anodes = c(\"A1\", \"A2\"), Lnodes = \"L\", Ynodes = \"Y\",  #>     abar = c(0, 0)) #>  #> TMLE Estimate:  0.5125557"},{"path":"http://joshuaschwab.github.io/ltmle/articles/a02_intro.html","id":"longitudinal-data-with-censoring","dir":"Articles","previous_headings":"","what":"Longitudinal data with censoring","title":"Introduction to ltmle","text":"W -> A1 -> C -> L -> A2 -> Y Treatment regime interest: set A1 1, set A2 0, set C uncensored:","code":"n <- 1000 W <- rnorm(n) A1 <- rexpit(W) C <- BinaryToCensoring(is.censored = rexpit(0.6 * W - 0.5 * A1)) uncensored <- C == \"uncensored\" L <- A2 <- Y <- rep(NA, n) L[uncensored] <- (0.3 * W[uncensored] + 0.2 * A1[uncensored] + rnorm(sum(uncensored))) A2[uncensored] <- rexpit(W[uncensored] + A1[uncensored] + L[uncensored]) Y[uncensored] <- rexpit(W[uncensored] - 0.6 * A1[uncensored] + L[uncensored] - 0.8 * A2[uncensored]) data <- data.frame(W, A1, C, L, A2, Y) head(data) #>             W A1          C           L A2  Y #> 1 -1.66876094  0 uncensored  0.90226587  0  1 #> 2  1.24746104  1   censored          NA NA NA #> 3 -0.19406730  0 uncensored -1.16705004  1  0 #> 4  0.39115694  1   censored          NA NA NA #> 5 -0.07899477  0   censored          NA NA NA #> 6  0.48802471  1 uncensored -0.05243272  1  0 ltmle(data, Anodes=c(\"A1\", \"A2\"), Cnodes = \"C\", Lnodes=\"L\", Ynodes=\"Y\", abar=c(1, 0)) #> Qform not specified, using defaults: #> formula for L: #> Q.kplus1 ~ W + A1 #> formula for Y: #> Q.kplus1 ~ W + A1 + L + A2 #>  #> gform not specified, using defaults: #> formula for A1: #> A1 ~ W #> formula for C: #> C ~ W + A1 #> formula for A2: #> A2 ~ W + A1 + L #>  #> Estimate of time to completion: < 1 minute #> Call: #> ltmle(data = data, Anodes = c(\"A1\", \"A2\"), Cnodes = \"C\", Lnodes = \"L\",  #>     Ynodes = \"Y\", abar = c(1, 0)) #>  #> TMLE Estimate:  0.485589"},{"path":"http://joshuaschwab.github.io/ltmle/articles/a02_intro.html","id":"dynamic-treatment","dir":"Articles","previous_headings":"","what":"Dynamic treatment","title":"Introduction to ltmle","text":"Treatment regime interest : Always treat time 1 (A1 = 1), treat time 2 (A2 = 1) L > 0 regime can also specified rule function. rule function applied row data returns numeric vector length Anodes. Specfifying regime using abar using rule give result:","code":"abar <- matrix(nrow=n, ncol=2) abar[, 1] <- 1 abar[, 2] <- L > 0  result.abar <- ltmle(data, Anodes=c(\"A1\", \"A2\"), Cnodes = \"C\", Lnodes=\"L\", Ynodes=\"Y\", abar=abar) #> Qform not specified, using defaults: #> formula for L: #> Q.kplus1 ~ W + A1 #> formula for Y: #> Q.kplus1 ~ W + A1 + L + A2 #>  #> gform not specified, using defaults: #> formula for A1: #> A1 ~ W #> formula for C: #> C ~ W + A1 #> formula for A2: #> A2 ~ W + A1 + L #>  #> Estimate of time to completion: < 1 minute result.abar #> Call: #> ltmle(data = data, Anodes = c(\"A1\", \"A2\"), Cnodes = \"C\", Lnodes = \"L\",  #>     Ynodes = \"Y\", abar = abar) #>  #> TMLE Estimate:  0.3440237 rule <- function(row) c(1, row[\"L\"] > 0)  result.rule <- ltmle(data, Anodes=c(\"A1\", \"A2\"), Cnodes = \"C\", Lnodes=\"L\", Ynodes=\"Y\", rule=rule) #> Qform not specified, using defaults: #> formula for L: #> Q.kplus1 ~ W + A1 #> formula for Y: #> Q.kplus1 ~ W + A1 + L + A2 #>  #> gform not specified, using defaults: #> formula for A1: #> A1 ~ W #> formula for C: #> C ~ W + A1 #> formula for A2: #> A2 ~ W + A1 + L #>  #> Estimate of time to completion: < 1 minute result.rule #> Call: #> ltmle(data = data, Anodes = c(\"A1\", \"A2\"), Cnodes = \"C\", Lnodes = \"L\",  #>     Ynodes = \"Y\", rule = rule) #>  #> TMLE Estimate:  0.3440237 summary(result.abar) #> Estimator:  tmle  #> Call: #> ltmle(data = data, Anodes = c(\"A1\", \"A2\"), Cnodes = \"C\", Lnodes = \"L\",  #>     Ynodes = \"Y\", abar = abar) #>  #>    Parameter Estimate:  0.34402  #>     Estimated Std Err:  0.037297  #>               p-value:  <2e-16  #>     95% Conf Interval: (0.27092, 0.41712) summary(result.rule) #> Estimator:  tmle  #> Call: #> ltmle(data = data, Anodes = c(\"A1\", \"A2\"), Cnodes = \"C\", Lnodes = \"L\",  #>     Ynodes = \"Y\", rule = rule) #>  #>    Parameter Estimate:  0.34402  #>     Estimated Std Err:  0.037297  #>               p-value:  <2e-16  #>     95% Conf Interval: (0.27092, 0.41712)"},{"path":"http://joshuaschwab.github.io/ltmle/articles/a02_intro.html","id":"variance-estimation","dir":"Articles","previous_headings":"","what":"Variance estimation","title":"Introduction to ltmle","text":"Consider simple point treatment problem observed data \\(W, , Y\\). positivity problem - small values \\(W\\), \\(Prob(= 1)\\) small. true parameter value, \\(E[Y_1]\\) approximately 0.697. true TMLE standard deviation (standard deviation TMLE estimate ran many times many sets data) approximately 0.056. true IPTW standard deviation (standard deviation IPTW estimate ran many times many sets data) approximately 0.059. default variance.method \"tmle\" - use TMLE order approximate variance TMLE estimator. estimated standard deviation close true TMLE standard deviation. variance.method \"ic\", variance estimated using estimated Influence Curve. fast compute, may significantly anticonservative data positivity violations. variance.method \"iptw\", use IPTW order approximate variance TMLE estimator. faster compute variance.method = \"tmle\" less accurate (slower compute variance.method = \"ic\" accurate). use IPTW estimator, variance.method change estimated standard deviation (affects estimated standard deviation TMLE estimator). can see values g small.","code":"n <- 1000 W <- rnorm(n) A <- rexpit(4 * W) Y <- rexpit(W + A) df <- data.frame(W, A, Y) r1 <- ltmle(df, Anodes=\"A\", Ynodes=\"Y\", abar = 1, estimate.time=FALSE) #> Qform not specified, using defaults: #> formula for Y: #> Q.kplus1 ~ W + A #>  #> gform not specified, using defaults: #> formula for A: #> A ~ W #>  print(summary(r1)) #> Estimator:  tmle  #> Call: #> ltmle(data = df, Anodes = \"A\", Ynodes = \"Y\", abar = 1, estimate.time = FALSE) #>  #>    Parameter Estimate:  0.77069  #>     Estimated Std Err:  0.056061  #>               p-value:  <2e-16  #>     95% Conf Interval: (0.66081, 0.88057) r2 <- ltmle(df, Anodes=\"A\", Ynodes=\"Y\", abar = 1, estimate.time=FALSE,   variance.method=\"ic\") #> Qform not specified, using defaults: #> formula for Y: #> Q.kplus1 ~ W + A #>  #> gform not specified, using defaults: #> formula for A: #> A ~ W #>  #> Warning in CheckForVarianceWarning(inputs, g.ratio): Variance estimate is based #> on influence curve only, which may be significantly anticonservative because #> your data appears to contain positivity violations. It is recommended to use #> variance.method='tmle' or variance.method='iptw' to obtain a more robust #> variance estimate (but run time may be significantly longer). See #> variance.method details in ?ltmle print(summary(r2)) #> Estimator:  tmle  #> Call: #> ltmle(data = df, Anodes = \"A\", Ynodes = \"Y\", abar = 1, estimate.time = FALSE,  #>     variance.method = \"ic\") #>  #>    Parameter Estimate:  0.77069  #>     Estimated Std Err:  0.055874  #>               p-value:  <2e-16  #>     95% Conf Interval: (0.66118, 0.8802) r3 <- ltmle(df, Anodes=\"A\", Ynodes=\"Y\", abar = 1, estimate.time=FALSE,   variance.method=\"iptw\") #> Qform not specified, using defaults: #> formula for Y: #> Q.kplus1 ~ W + A #>  #> gform not specified, using defaults: #> formula for A: #> A ~ W #>  print(summary(r3)) #> Estimator:  tmle  #> Call: #> ltmle(data = df, Anodes = \"A\", Ynodes = \"Y\", abar = 1, estimate.time = FALSE,  #>     variance.method = \"iptw\") #>  #>    Parameter Estimate:  0.77069  #>     Estimated Std Err:  0.055874  #>               p-value:  <2e-16  #>     95% Conf Interval: (0.66118, 0.8802) print(summary(r1, estimator=\"iptw\")) #> Estimator:  iptw  #> Call: #> ltmle(data = df, Anodes = \"A\", Ynodes = \"Y\", abar = 1, estimate.time = FALSE) #>  #>    Parameter Estimate:  0.79568  #>     Estimated Std Err:  0.033435  #>               p-value:  <2e-16  #>     95% Conf Interval: (0.73015, 0.86121) print(summary(r2, estimator=\"iptw\")) #the same - variance.method only affects TMLE #> Estimator:  iptw  #> Call: #> ltmle(data = df, Anodes = \"A\", Ynodes = \"Y\", abar = 1, estimate.time = FALSE,  #>     variance.method = \"ic\") #>  #>    Parameter Estimate:  0.79568  #>     Estimated Std Err:  0.033435  #>               p-value:  <2e-16  #>     95% Conf Interval: (0.73015, 0.86121) print(summary(r3, estimator=\"iptw\")) #the same - variance.method only affects TMLE #> Estimator:  iptw  #> Call: #> ltmle(data = df, Anodes = \"A\", Ynodes = \"Y\", abar = 1, estimate.time = FALSE,  #>     variance.method = \"iptw\") #>  #>    Parameter Estimate:  0.79568  #>     Estimated Std Err:  0.033435  #>               p-value:  <2e-16  #>     95% Conf Interval: (0.73015, 0.86121) summary(r1$cum.g) #>        V1         #>  Min.   :0.0100   #>  1st Qu.:0.0700   #>  Median :0.4690   #>  Mean   :0.4967   #>  3rd Qu.:0.9230   #>  Max.   :1.0000 summary(r1$cum.g.unbounded) #>        V1           #>  Min.   :4.40e-06   #>  1st Qu.:7.00e-02   #>  Median :4.69e-01   #>  Mean   :4.96e-01   #>  3rd Qu.:9.23e-01   #>  Max.   :1.00e+00 head(data.frame(df, g = r1$cum.g, g.unbounded = r1$cum.g.unbounded), 20) #>               W A Y          g  g.unbounded #> 1   0.836166556 1 1 0.95876785 0.9587678483 #> 2  -0.059736735 1 0 0.43917034 0.4391703416 #> 3  -0.433613265 0 0 0.15981052 0.1598105220 #> 4  -0.046876214 0 0 0.45119260 0.4511925987 #> 5  -1.952066247 0 0 0.01000000 0.0006066654 #> 6   0.006562874 1 1 0.50160292 0.5016029157 #> 7   0.385083025 1 1 0.80831467 0.8083146720 #> 8   0.417982170 1 1 0.82687195 0.8268719499 #> 9  -1.213353120 0 0 0.01000000 0.0098447368 #> 10 -0.445953345 0 1 0.15363835 0.1536383481 #> 11 -0.887786157 0 0 0.03296890 0.0329688990 #> 12  1.843378143 1 1 0.99905056 0.9990505605 #> 13 -0.836944649 0 0 0.03968711 0.0396871071 #> 14 -0.292998360 0 0 0.24463821 0.2446382104 #> 15 -1.076864189 0 0 0.01639385 0.0163938502 #> 16  1.233745607 1 1 0.99054070 0.9905406993 #> 17  0.327978570 0 1 0.77258370 0.7725836989 #> 18 -1.477008252 0 0 0.01000000 0.0036518982 #> 19 -1.246346575 0 0 0.01000000 0.0086990549 #> 20  1.103467031 1 1 0.98460432 0.9846043207"},{"path":"http://joshuaschwab.github.io/ltmle/articles/a02_intro.html","id":"hierarchical-data-and-the-id-variable","dir":"Articles","previous_headings":"","what":"Hierarchical data and the id variable","title":"Introduction to ltmle","text":"id argument can used specify hierarchical data, people household. id can integer, factor, character (type can coerced factor), Omitting id argument makes individuals seem independent , gives artificially low variance estimates. influence curve vector length equal number independent units.","code":"num.households <- 500 people.in.household <- round(runif(num.households, min = 1, max = 10)) length(people.in.household) #> [1] 500 n <- sum(people.in.household)  n #> [1] 2743 W.household <- rnorm(num.households) length(W.household) #> [1] 500 W.household.expanded <- rep(W.household, times = people.in.household) W.indiv <- rnorm(n) length(W.indiv) #> [1] 2743 A <- rexpit(1.5 * W.household.expanded + 0.4 * W.indiv) Y <- rexpit(-1 + 2.3 * W.household.expanded - 0.6 * W.indiv + 1.2 * A) id <- 1:num.households  id.expanded <- rep(id, times = people.in.household) data <- data.frame(W.household.expanded, W.indiv, A, Y) head(cbind(id.expanded, data), 20) #>    id.expanded W.household.expanded     W.indiv A Y #> 1            1           0.01688324 -1.90793098 0 0 #> 2            1           0.01688324 -1.52619948 0 0 #> 3            1           0.01688324 -0.16176603 1 0 #> 4            1           0.01688324  1.47515523 1 0 #> 5            1           0.01688324  0.75293782 1 1 #> 6            1           0.01688324  0.36665981 1 0 #> 7            1           0.01688324  0.85884321 1 1 #> 8            2           0.88439445  0.46890050 0 0 #> 9            3          -0.16197058  1.09025508 1 1 #> 10           3          -0.16197058 -2.37211851 1 1 #> 11           3          -0.16197058 -0.48961924 0 0 #> 12           3          -0.16197058  0.03714545 1 1 #> 13           3          -0.16197058 -0.86694851 0 0 #> 14           3          -0.16197058  0.43133379 1 0 #> 15           3          -0.16197058 -0.76931551 1 0 #> 16           3          -0.16197058 -0.13871111 1 1 #> 17           3          -0.16197058  0.09130988 0 0 #> 18           3          -0.16197058 -0.21519917 0 0 #> 19           4           0.83732575  1.05580850 0 1 #> 20           4           0.83732575 -1.12245533 0 1 result.without.id <- ltmle(data, Anodes = \"A\", Ynodes = \"Y\", abar = 0) #> Qform not specified, using defaults: #> formula for Y: #> Q.kplus1 ~ W.household.expanded + W.indiv + A #>  #> gform not specified, using defaults: #> formula for A: #> A ~ W.household.expanded + W.indiv #>  #> Estimate of time to completion: < 1 minute result.with.id <- ltmle(data, Anodes = \"A\", Ynodes = \"Y\", abar = 0, id = id.expanded) #> Qform not specified, using defaults: #> formula for Y: #> Q.kplus1 ~ W.household.expanded + W.indiv + A #>  #> gform not specified, using defaults: #> formula for A: #> A ~ W.household.expanded + W.indiv #>  #> Estimate of time to completion: < 1 minute summary(result.without.id) #> Estimator:  tmle  #> Call: #> ltmle(data = data, Anodes = \"A\", Ynodes = \"Y\", abar = 0) #>  #>    Parameter Estimate:  0.38342  #>     Estimated Std Err:  0.013475  #>               p-value:  <2e-16  #>     95% Conf Interval: (0.35701, 0.40983) summary(result.with.id) #> Estimator:  tmle  #> Call: #> ltmle(data = data, Anodes = \"A\", Ynodes = \"Y\", abar = 0, id = id.expanded) #>  #>    Parameter Estimate:  0.38342  #>     Estimated Std Err:  0.020518  #>               p-value:  <2e-16  #>     95% Conf Interval: (0.3432, 0.42363) length(result.without.id$IC$tmle) #> [1] 2743 length(result.with.id$IC$tmle) #> [1] 500"},{"path":"http://joshuaschwab.github.io/ltmle/articles/a02_intro.html","id":"multiple-time-dependent-covariates-and-treatments-at-each-time-point-continuous-y-values","dir":"Articles","previous_headings":"","what":"Multiple time-dependent covariates and treatments at each time point, continuous Y values","title":"Introduction to ltmle","text":"age -> gender -> A1 -> L1a -> L1b -> Y1 -> A2 -> L2a -> L2b -> Y2 Also show different ways specifying nodes (either names indexes works):","code":"n <- 1000 age <- rbinom(n, 1, 0.5) gender <- rbinom(n, 1, 0.5) A1 <- rexpit(age + gender) L1a <- 2*age - 3*gender + 2*A1 + rnorm(n) L1b <- rexpit(age + 1.5*gender - A1) Y1 <- plogis(age - gender + L1a + 0.7*L1b + A1 + rnorm(n)) A2 <- rexpit(age + gender + A1 - L1a - L1b) L2a <- 2*age - 3*gender + 2*A1 + A2 + rnorm(n) L2b <- rexpit(age + 1.5*gender - A1 - A2) Y2 <- plogis(age - gender + L1a + L1b + A1 + 1.8*A2 + rnorm(n)) data <- data.frame(age, gender, A1, L1a, L1b, Y1, A2, L2a, L2b, Y2) result <- ltmle(data, Anodes=c(3, 7), Lnodes=c(\"L1a\", \"L1b\", \"L2a\", \"L2b\"),   Ynodes=grep(\"^Y\", names(data)), abar=c(1, 0))  #> Qform not specified, using defaults: #> formula for L1a: #> Q.kplus1 ~ age + gender + A1 #> formula for L2a: #> Q.kplus1 ~ age + gender + A1 + L1a + L1b + Y1 + A2 #>  #> gform not specified, using defaults: #> formula for A1: #> A1 ~ age + gender #> formula for A2: #> A2 ~ age + gender + A1 + L1a + L1b + Y1 #>  #> Estimate of time to completion: < 1 minute #> Warning in CheckForVarianceWarning(inputs, g.ratio): Variance estimate is based #> on influence curve only, which may be significantly anticonservative because #> your data appears to contain positivity violations. Robust variance estimate is #> not currently available with non binary outcomes but this will be addressed in #> a future release. summary(result) #> Estimator:  tmle  #> Call: #> ltmle(data = data, Anodes = c(3, 7), Lnodes = c(\"L1a\", \"L1b\",  #>     \"L2a\", \"L2b\"), Ynodes = grep(\"^Y\", names(data)), abar = c(1,  #>     0)) #>  #>    Parameter Estimate:  0.80812  #>     Estimated Std Err:  0.019357  #>               p-value:  <2e-16  #>     95% Conf Interval: (0.77018, 0.84606)"},{"path":"http://joshuaschwab.github.io/ltmle/articles/a02_intro.html","id":"specifying-qform","dir":"Articles","previous_headings":"","what":"Specifying Qform","title":"Introduction to ltmle","text":"Usually specify Qform Lnodes Ynodes case L1a, L1b, Y1 “block” L/Y nodes separated Anodes Cnodes (true L2a, L2b, Y2). one regression required first L/Y node block. can pass regression formulas L/Y nodes, ignored. Gives result prints message saying regression formulas dropped: Anode Cnode L1b Y1, Y1 also need Q regression formula.","code":"result <- ltmle(data, Anodes=c(3, 7), Lnodes=c(\"L1a\", \"L1b\", \"L2a\", \"L2b\"),   Ynodes=grep(\"^Y\", names(data)), abar=c(1, 0),   Qform=c(L1a=\"Q.kplus1 ~ 1\", L2a=\"Q.kplus1 ~ 1\")) #> gform not specified, using defaults: #> formula for A1: #> A1 ~ age + gender #> formula for A2: #> A2 ~ age + gender + A1 + L1a + L1b + Y1 #>  #> Estimate of time to completion: < 1 minute #> Warning in CheckForVarianceWarning(inputs, g.ratio): Variance estimate is based #> on influence curve only, which may be significantly anticonservative because #> your data appears to contain positivity violations. Robust variance estimate is #> not currently available with non binary outcomes but this will be addressed in #> a future release. summary(result) #> Estimator:  tmle  #> Call: #> ltmle(data = data, Anodes = c(3, 7), Lnodes = c(\"L1a\", \"L1b\",  #>     \"L2a\", \"L2b\"), Ynodes = grep(\"^Y\", names(data)), Qform = c(L1a = \"Q.kplus1 ~ 1\",  #>     L2a = \"Q.kplus1 ~ 1\"), abar = c(1, 0)) #>  #>    Parameter Estimate:  0.78629  #>     Estimated Std Err:  0.042667  #>               p-value:  <2e-16  #>     95% Conf Interval: (0.70266, 0.86991) result <- ltmle(data, Anodes=c(3, 7), Lnodes=c(\"L1a\", \"L1b\", \"L2a\", \"L2b\"),   Ynodes=grep(\"^Y\", names(data)), abar=c(1, 0),   Qform=c(L1a=\"Q.kplus1 ~ 1\", L1b=\"Q.klus1~A1\",   Y1=\"Q.kplus1~L1a\", L2a=\"Q.kplus1 ~ 1\", L2b=\"Q.klus1~A1\", Y2=\"Q.kplus1~A2 + gender\")) #> L/Y nodes (after removing blocks)  : L1a L2a #> Qform names                        : L1a L1b Y1 L2a L2b Y2 #> The following nodes are not being considered as L/Y nodes because they are part of a block #> of L/Y nodes. They are being dropped from Qform: #> L1b  #>  Y1  #>  L2b  #>  Y2 #> gform not specified, using defaults: #> formula for A1: #> A1 ~ age + gender #> formula for A2: #> A2 ~ age + gender + A1 + L1a + L1b + Y1 #>  #> Estimate of time to completion: < 1 minute #> Warning in CheckForVarianceWarning(inputs, g.ratio): Variance estimate is based #> on influence curve only, which may be significantly anticonservative because #> your data appears to contain positivity violations. Robust variance estimate is #> not currently available with non binary outcomes but this will be addressed in #> a future release. summary(result) #> Estimator:  tmle  #> Call: #> ltmle(data = data, Anodes = c(3, 7), Lnodes = c(\"L1a\", \"L1b\",  #>     \"L2a\", \"L2b\"), Ynodes = grep(\"^Y\", names(data)), Qform = c(L1a = \"Q.kplus1 ~ 1\",  #>     L1b = \"Q.klus1~A1\", Y1 = \"Q.kplus1~L1a\", L2a = \"Q.kplus1 ~ 1\",  #>     L2b = \"Q.klus1~A1\", Y2 = \"Q.kplus1~A2 + gender\"), abar = c(1,  #>     0)) #>  #>    Parameter Estimate:  0.78629  #>     Estimated Std Err:  0.042667  #>               p-value:  <2e-16  #>     95% Conf Interval: (0.70266, 0.86991)"},{"path":"http://joshuaschwab.github.io/ltmle/articles/a03_msm.html","id":"marginal-structural-models-msms---multiple-regimes-with-a-single-outcome","dir":"Articles","previous_headings":"","what":"Marginal Structural Models (MSMs) - Multiple regimes with a single outcome","title":"Marginal Structural Models - ltmleMSM","text":"example 5 time points treatment time varying covariate. , treatment can 0 1. single outcome Y. L_0 L_1 A_1 L_2 A_2 … L_5 A_5 Y 2^5 = 32 regimes interest. may limited support patients follow particular regime. pool regimes using working marginal structural model. example want know effect time treatment Y. include time..treatment time..treatment^2. large numbers regimes, variance.method = \"ic\" much faster, may give anticonservative confidence intervals. may want use variance.method = \"ic\" first make sure MSM coefficients look reasonable use variance.method = \"tmle\" (default) final estimates. Suppose interested effect time treatment Y considering regimes include least 3 periods treatment.","code":"rexpit <- function(x) rbinom(n=length(x), size=1, prob=plogis(x)) n <- 5000 time.points <- 5 prev.L <- rnorm(n) prev.A <- rep(0, n) sum.A <- rep(0, n) data <- data.frame(L_0 = prev.L) for (t in 1:time.points) {   L <- 0.1 * prev.L + 0.3 * prev.A + rnorm(n)   A <- rexpit(L)      data1 <- data.frame(L, A)   names(data1) <- paste0(c(\"L_\", \"A_\"), t)   data <- cbind(data, data1)      prev.A <- A   prev.L <- L      sum.A <- sum.A + A } data$Y <- rexpit(sum.A / time.points + L) head(data) #>          L_0        L_1 A_1        L_2 A_2        L_3 A_3         L_4 A_4 #> 1 -0.1109733 -0.4732041   1 -0.5918659   0  0.9759358   1  0.07745348   1 #> 2 -0.7823882 -0.1499512   1  0.1749458   0  1.1454179   1  0.46476771   0 #> 3  0.2868675  0.3775513   0 -0.8363367   0 -0.9073691   1  0.87036422   1 #> 4 -0.4429988  0.6005967   0  0.1665486   1  2.5704316   1  0.40069625   1 #> 5 -0.3576847  1.4868539   1  0.4095142   0  0.9274325   0 -0.75607527   1 #> 6  0.8914699  0.8806700   1  1.2822985   1  0.2503797   0  0.61927662   1 #>          L_5 A_5 Y #> 1 -2.0041680   0 1 #> 2 -1.2714831   0 0 #> 3 -0.7714984   1 1 #> 4  0.3483324   0 1 #> 5  1.0502339   1 1 #> 6  0.4153236   1 0 regime.matrix <- as.matrix(expand.grid(rep(list(0:1), time.points))) dim(regime.matrix) #> [1] 32  5 head(regime.matrix, 20) #>       Var1 Var2 Var3 Var4 Var5 #>  [1,]    0    0    0    0    0 #>  [2,]    1    0    0    0    0 #>  [3,]    0    1    0    0    0 #>  [4,]    1    1    0    0    0 #>  [5,]    0    0    1    0    0 #>  [6,]    1    0    1    0    0 #>  [7,]    0    1    1    0    0 #>  [8,]    1    1    1    0    0 #>  [9,]    0    0    0    1    0 #> [10,]    1    0    0    1    0 #> [11,]    0    1    0    1    0 #> [12,]    1    1    0    1    0 #> [13,]    0    0    1    1    0 #> [14,]    1    0    1    1    0 #> [15,]    0    1    1    1    0 #> [16,]    1    1    1    1    0 #> [17,]    0    0    0    0    1 #> [18,]    1    0    0    0    1 #> [19,]    0    1    0    0    1 #> [20,]    1    1    0    0    1 num.regimes <- 2^time.points regimes <- array(dim = c(n, time.points, num.regimes)) #n x numAnodes x numRegimes = n x time.points x 2^time.points summary.measures <- array(dim = c(num.regimes, 1, 1)) #numRegimes x num.summary.measures x num.final.Ynodes = 2^time.points x 1 x 1 for (i in 1:num.regimes) {   regimes[, , i] <- matrix(regime.matrix[i, ], byrow = TRUE, nrow = n, ncol = time.points)   summary.measures[i, 1, 1] <- sum(regime.matrix[i, ]) } colnames(summary.measures) <- \"time.on.treatment\" regimes[1:3, , 1:3] #> , , 1 #>  #>      [,1] [,2] [,3] [,4] [,5] #> [1,]    0    0    0    0    0 #> [2,]    0    0    0    0    0 #> [3,]    0    0    0    0    0 #>  #> , , 2 #>  #>      [,1] [,2] [,3] [,4] [,5] #> [1,]    1    0    0    0    0 #> [2,]    1    0    0    0    0 #> [3,]    1    0    0    0    0 #>  #> , , 3 #>  #>      [,1] [,2] [,3] [,4] [,5] #> [1,]    0    1    0    0    0 #> [2,]    0    1    0    0    0 #> [3,]    0    1    0    0    0 summary.measures #> , , 1 #>  #>       time.on.treatment #>  [1,]                 0 #>  [2,]                 1 #>  [3,]                 1 #>  [4,]                 2 #>  [5,]                 1 #>  [6,]                 2 #>  [7,]                 2 #>  [8,]                 3 #>  [9,]                 1 #> [10,]                 2 #> [11,]                 2 #> [12,]                 3 #> [13,]                 2 #> [14,]                 3 #> [15,]                 3 #> [16,]                 4 #> [17,]                 1 #> [18,]                 2 #> [19,]                 2 #> [20,]                 3 #> [21,]                 2 #> [22,]                 3 #> [23,]                 3 #> [24,]                 4 #> [25,]                 2 #> [26,]                 3 #> [27,]                 3 #> [28,]                 4 #> [29,]                 3 #> [30,]                 4 #> [31,]                 4 #> [32,]                 5 result1 <- ltmleMSM(data, Anodes = paste0(\"A_\", 1:time.points),                      Lnodes = paste0(\"L_\", 0:time.points), Ynodes = \"Y\",                      regimes = regimes, summary.measures = summary.measures,                      working.msm = \"Y ~ time.on.treatment + I(time.on.treatment^2)\",                     variance.method = \"ic\") #> Qform not specified, using defaults: #> formula for L_2: #> Q.kplus1 ~ L_0 + L_1 + A_1 #> formula for L_3: #> Q.kplus1 ~ L_0 + L_1 + A_1 + L_2 + A_2 #> formula for L_4: #> Q.kplus1 ~ L_0 + L_1 + A_1 + L_2 + A_2 + L_3 + A_3 #> formula for L_5: #> Q.kplus1 ~ L_0 + L_1 + A_1 + L_2 + A_2 + L_3 + A_3 + L_4 + A_4 #> formula for Y: #> Q.kplus1 ~ L_0 + L_1 + A_1 + L_2 + A_2 + L_3 + A_3 + L_4 + A_4 +     L_5 + A_5 #>  #> gform not specified, using defaults: #> formula for A_1: #> A_1 ~ L_0 + L_1 #> formula for A_2: #> A_2 ~ L_0 + L_1 + A_1 + L_2 #> formula for A_3: #> A_3 ~ L_0 + L_1 + A_1 + L_2 + A_2 + L_3 #> formula for A_4: #> A_4 ~ L_0 + L_1 + A_1 + L_2 + A_2 + L_3 + A_3 + L_4 #> formula for A_5: #> A_5 ~ L_0 + L_1 + A_1 + L_2 + A_2 + L_3 + A_3 + L_4 + A_4 + L_5 #>  #> Estimate of time to completion: 1 minute #> Warning in CheckForVarianceWarning(inputs, g.ratio): Variance estimate is based #> on influence curve only, which may be significantly anticonservative because #> your data appears to contain positivity violations. It is recommended to use #> variance.method='tmle' or variance.method='iptw' to obtain a more robust #> variance estimate (but run time may be significantly longer). See #> variance.method details in ?ltmle result2 <- ltmleMSM(data, Anodes = paste0(\"A_\", 1:time.points),                      Lnodes = paste0(\"L_\", 0:time.points), Ynodes = \"Y\",                      regimes = regimes, summary.measures = summary.measures,                      working.msm = \"Y ~ time.on.treatment + I(time.on.treatment^2)\") #> Qform not specified, using defaults: #> formula for L_2: #> Q.kplus1 ~ L_0 + L_1 + A_1 #> formula for L_3: #> Q.kplus1 ~ L_0 + L_1 + A_1 + L_2 + A_2 #> formula for L_4: #> Q.kplus1 ~ L_0 + L_1 + A_1 + L_2 + A_2 + L_3 + A_3 #> formula for L_5: #> Q.kplus1 ~ L_0 + L_1 + A_1 + L_2 + A_2 + L_3 + A_3 + L_4 + A_4 #> formula for Y: #> Q.kplus1 ~ L_0 + L_1 + A_1 + L_2 + A_2 + L_3 + A_3 + L_4 + A_4 +     L_5 + A_5 #>  #> gform not specified, using defaults: #> formula for A_1: #> A_1 ~ L_0 + L_1 #> formula for A_2: #> A_2 ~ L_0 + L_1 + A_1 + L_2 #> formula for A_3: #> A_3 ~ L_0 + L_1 + A_1 + L_2 + A_2 + L_3 #> formula for A_4: #> A_4 ~ L_0 + L_1 + A_1 + L_2 + A_2 + L_3 + A_3 + L_4 #> formula for A_5: #> A_5 ~ L_0 + L_1 + A_1 + L_2 + A_2 + L_3 + A_3 + L_4 + A_4 + L_5 #>  #> Estimate of time to completion: 5 to 27 minutes summary(result1) #> Estimator:  tmle  #>                         Estimate Std. Error   CI 2.5% CI 97.5% p-value   #> (Intercept)             0.067797   0.136390 -0.199522    0.335  0.6191   #> time.on.treatment       0.188909   0.112493 -0.031572    0.409  0.0931 . #> I(time.on.treatment^2)  0.003259   0.021665 -0.039205    0.046  0.8804   #> --- #> Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1 summary(result2) #> Estimator:  tmle  #>                         Estimate Std. Error   CI 2.5% CI 97.5% p-value #> (Intercept)             0.067797   0.182351 -0.289604    0.425   0.710 #> time.on.treatment       0.188909   0.145862 -0.096976    0.475   0.195 #> I(time.on.treatment^2)  0.003259   0.027598 -0.050833    0.057   0.906 at.least.3 <- summary.measures[, \"time.on.treatment\", 1] >= 3 regimes.3 <- regimes[, , at.least.3] summary.measures.3 <- summary.measures[at.least.3, , , drop = F] dim(regimes.3) #> [1] 5000    5   16 summary.measures.3 #> , , 1 #>  #>       time.on.treatment #>  [1,]                 3 #>  [2,]                 3 #>  [3,]                 3 #>  [4,]                 3 #>  [5,]                 4 #>  [6,]                 3 #>  [7,]                 3 #>  [8,]                 3 #>  [9,]                 4 #> [10,]                 3 #> [11,]                 3 #> [12,]                 4 #> [13,]                 3 #> [14,]                 4 #> [15,]                 4 #> [16,]                 5  result <- ltmleMSM(data, Anodes = paste0(\"A_\", 1:time.points),                     Lnodes = paste0(\"L_\", 0:time.points),                     Ynodes = \"Y\", regimes = regimes.3,                     summary.measures = summary.measures.3,                     working.msm = \"Y ~ time.on.treatment + I(time.on.treatment^2)\") #> Qform not specified, using defaults: #> formula for L_2: #> Q.kplus1 ~ L_0 + L_1 + A_1 #> formula for L_3: #> Q.kplus1 ~ L_0 + L_1 + A_1 + L_2 + A_2 #> formula for L_4: #> Q.kplus1 ~ L_0 + L_1 + A_1 + L_2 + A_2 + L_3 + A_3 #> formula for L_5: #> Q.kplus1 ~ L_0 + L_1 + A_1 + L_2 + A_2 + L_3 + A_3 + L_4 + A_4 #> formula for Y: #> Q.kplus1 ~ L_0 + L_1 + A_1 + L_2 + A_2 + L_3 + A_3 + L_4 + A_4 +     L_5 + A_5 #>  #> gform not specified, using defaults: #> formula for A_1: #> A_1 ~ L_0 + L_1 #> formula for A_2: #> A_2 ~ L_0 + L_1 + A_1 + L_2 #> formula for A_3: #> A_3 ~ L_0 + L_1 + A_1 + L_2 + A_2 + L_3 #> formula for A_4: #> A_4 ~ L_0 + L_1 + A_1 + L_2 + A_2 + L_3 + A_3 + L_4 #> formula for A_5: #> A_5 ~ L_0 + L_1 + A_1 + L_2 + A_2 + L_3 + A_3 + L_4 + A_4 + L_5 #>  #> Estimate of time to completion: 4 to 13 minutes summary(result) #> Estimator:  tmle  #>                        Estimate Std. Error CI 2.5% CI 97.5% p-value #> (Intercept)              1.9545     2.1989 -2.3553    6.264   0.374 #> time.on.treatment       -0.9681     1.2073 -3.3344    1.398   0.423 #> I(time.on.treatment^2)   0.1695     0.1613 -0.1467    0.486   0.293"},{"path":"http://joshuaschwab.github.io/ltmle/articles/a03_msm.html","id":"marginal-structural-models-msms---switching-time-example---multiple-regimes-and-outcomes","dir":"Articles","previous_headings":"","what":"Marginal Structural Models (MSMs) - Switching time example - Multiple regimes and outcomes","title":"Marginal Structural Models - ltmleMSM","text":"Given data 3 time points switches 1 stays 1. want know death varies function gender, time indicator whether patient’s intended regime switch time. Note working.msm includes time switch.time, columns summary.measures; working.msm also includes male, ok baseline covariate (comes /C/L/Y nodes). msm.weights just example. also 200x3x4 array NULL (weights), \"empirical\" (default). regimes can also specified list rule functions rule function applied row data returns numeric vector length Anodes. result.regimes: Suppose interested pooling result Y1 Y3. interested result Y3. time now constant working.msm, let’s remove .","code":"data(sampleDataForLtmleMSM) head(sampleDataForLtmleMSM$data, 20) #>    male age CD4_0 A0 Y1 CD4_1 A1 Y2 CD4_2 A2 Y3 #> 1     1  33   347  0  0   349  0  0   315  0  0 #> 2     0  18   277  0  0   302  0  0   300  0  0 #> 3     1  33   419  0  0   423  0  0   462  0  0 #> 4     1  35   318  1  0   358  1  0   413  1  0 #> 5     0  27   145  0  0   134  1  1    NA NA  1 #> 6     1  27   320  0  0   332  0  0   347  1  0 #> 7     1  35   220  0  0   241  0  0   216  1  0 #> 8     0  31   184  0  0   202  1  0   230  1  0 #> 9     0  35   289  0  0   302  0  0   290  0  0 #> 10    0  30   295  1  0   312  1  0   340  1  0 #> 11    0  31   300  1  0   394  1  0   467  1  0 #> 12    0  30   300  0  0   331  0  0   320  0  0 #> 13    0  25   276  0  1    NA NA  1    NA NA  1 #> 14    1  26   242  1  0   280  1  0   307  1  0 #> 15    0  21   238  1  0   345  1  0   379  1  0 #> 16    1  30   304  0  0   258  0  0   287  0  0 #> 17    0  30   271  1  0   297  1  0   324  1  0 #> 18    1  27   296  0  0   305  0  0   306  0  0 #> 19    1  33   217  1  0   242  1  0   267  1  0 #> 20    1  25   337  0  0   360  0  0   390  0  0 dim(sampleDataForLtmleMSM$regimes) #> [1] 200   3   4 sampleDataForLtmleMSM$regimes[1:5, , ] #> , , 1 #>  #>      [,1] [,2] [,3] #> [1,]    1    1    1 #> [2,]    1    1    1 #> [3,]    1    1    1 #> [4,]    1    1    1 #> [5,]    1    1    1 #>  #> , , 2 #>  #>      [,1] [,2] [,3] #> [1,]    0    1    1 #> [2,]    0    1    1 #> [3,]    0    1    1 #> [4,]    0    1    1 #> [5,]    0    1    1 #>  #> , , 3 #>  #>      [,1] [,2] [,3] #> [1,]    0    0    1 #> [2,]    0    0    1 #> [3,]    0    0    1 #> [4,]    0    0    1 #> [5,]    0    0    1 #>  #> , , 4 #>  #>      [,1] [,2] [,3] #> [1,]    0    0    0 #> [2,]    0    0    0 #> [3,]    0    0    0 #> [4,]    0    0    0 #> [5,]    0    0    0 sampleDataForLtmleMSM$summary.measures #> , , 1 #>  #>      switch.time time #> [1,]           0    1 #> [2,]           1    1 #> [3,]           2    1 #> [4,]           3    1 #>  #> , , 2 #>  #>      switch.time time #> [1,]           0    2 #> [2,]           1    2 #> [3,]           2    2 #> [4,]           3    2 #>  #> , , 3 #>  #>      switch.time time #> [1,]           0    3 #> [2,]           1    3 #> [3,]           2    3 #> [4,]           3    3 Anodes <- c(\"A0\", \"A1\", \"A2\") Lnodes <- c(\"CD4_1\", \"CD4_2\") Ynodes <- c(\"Y1\", \"Y2\", \"Y3\") msm.weights <- matrix(1:12, nrow=4, ncol=3) result.regimes <- ltmleMSM(sampleDataForLtmleMSM$data, Anodes=Anodes,                     Lnodes=Lnodes, Ynodes=Ynodes,                     survivalOutcome=TRUE,                    regimes=sampleDataForLtmleMSM$regimes,                     summary.measures=sampleDataForLtmleMSM$summary.measures,                    final.Ynodes=Ynodes,                     working.msm=\"Y ~ male + time + pmax(time - switch.time, 0)\",                     msm.weights=msm.weights, estimate.time=FALSE) #> Qform not specified, using defaults: #> formula for Y1: #> Q.kplus1 ~ male + age + CD4_0 + A0 #> formula for Y2: #> Q.kplus1 ~ male + age + CD4_0 + A0 + CD4_1 + A1 #> formula for Y3: #> Q.kplus1 ~ male + age + CD4_0 + A0 + CD4_1 + A1 + CD4_2 + A2 #>  #> gform not specified, using defaults: #> formula for A0: #> A0 ~ male + age + CD4_0 #> formula for A1: #> A1 ~ male + age + CD4_0 + A0 + CD4_1 #> formula for A2: #> A2 ~ male + age + CD4_0 + A0 + CD4_1 + A1 + CD4_2 #>  print(summary(result.regimes)) #> Estimator:  tmle  #>                             Estimate Std. Error CI 2.5% CI 97.5%  p-value     #> (Intercept)                  -3.4059     0.6545 -4.6886   -2.123 1.95e-07 *** #> male                         -0.3802     0.5305 -1.4198    0.660  0.47360     #> time                          0.7241     0.2602  0.2141    1.234  0.00539 **  #> pmax(time - switch.time, 0)  -0.4717     0.2019 -0.8675   -0.076  0.01948 *   #> --- #> Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1 regimesList <- list(function(row) c(1,1,1),                      function(row) c(0,1,1),                      function(row) c(0,0,1),                      function(row) c(0,0,0)) result.regList <- ltmleMSM(sampleDataForLtmleMSM$data, Anodes=Anodes,                     Lnodes=Lnodes, Ynodes=Ynodes,                     survivalOutcome=TRUE, regimes=regimesList,                     summary.measures=sampleDataForLtmleMSM$summary.measures,                    final.Ynodes=Ynodes,                     working.msm=\"Y ~ male + time + pmax(time - switch.time, 0)\",                     msm.weights=msm.weights, estimate.time=FALSE) #> Qform not specified, using defaults: #> formula for Y1: #> Q.kplus1 ~ male + age + CD4_0 + A0 #> formula for Y2: #> Q.kplus1 ~ male + age + CD4_0 + A0 + CD4_1 + A1 #> formula for Y3: #> Q.kplus1 ~ male + age + CD4_0 + A0 + CD4_1 + A1 + CD4_2 + A2 #>  #> gform not specified, using defaults: #> formula for A0: #> A0 ~ male + age + CD4_0 #> formula for A1: #> A1 ~ male + age + CD4_0 + A0 + CD4_1 #> formula for A2: #> A2 ~ male + age + CD4_0 + A0 + CD4_1 + A1 + CD4_2 #> print(summary(result.regList))          #> Estimator:  tmle  #>                             Estimate Std. Error CI 2.5% CI 97.5%  p-value     #> (Intercept)                  -3.4059     0.6545 -4.6886   -2.123 1.95e-07 *** #> male                         -0.3802     0.5305 -1.4198    0.660  0.47360     #> time                          0.7241     0.2602  0.2141    1.234  0.00539 **  #> pmax(time - switch.time, 0)  -0.4717     0.2019 -0.8675   -0.076  0.01948 *   #> --- #> Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1 result <- ltmleMSM(sampleDataForLtmleMSM$data, Anodes=Anodes,                     Lnodes=Lnodes, Ynodes=Ynodes,                     survivalOutcome=TRUE,                    regimes=sampleDataForLtmleMSM$regimes,                     summary.measures=sampleDataForLtmleMSM$summary.measures[, , c(1, 3)],                    final.Ynodes=c(\"Y1\", \"Y3\"),                     working.msm=\"Y ~ male + time + pmax(time - switch.time, 0)\",                     estimate.time=FALSE) #> Qform not specified, using defaults: #> formula for Y1: #> Q.kplus1 ~ male + age + CD4_0 + A0 #> formula for Y2: #> Q.kplus1 ~ male + age + CD4_0 + A0 + CD4_1 + A1 #> formula for Y3: #> Q.kplus1 ~ male + age + CD4_0 + A0 + CD4_1 + A1 + CD4_2 + A2 #>  #> gform not specified, using defaults: #> formula for A0: #> A0 ~ male + age + CD4_0 #> formula for A1: #> A1 ~ male + age + CD4_0 + A0 + CD4_1 #> formula for A2: #> A2 ~ male + age + CD4_0 + A0 + CD4_1 + A1 + CD4_2 #>  summary(result) #> Estimator:  tmle  #>                             Estimate Std. Error CI 2.5% CI 97.5%  p-value     #> (Intercept)                  -3.8891     0.5532 -4.9733   -2.805 2.06e-12 *** #> male                          0.2256     0.5144 -0.7826    1.234 0.660969     #> time                          0.7826     0.2314  0.3291    1.236 0.000718 *** #> pmax(time - switch.time, 0)  -0.4331     0.2018 -0.8287   -0.038 0.031874 *   #> --- #> Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1 result <- ltmleMSM(sampleDataForLtmleMSM$data, Anodes=Anodes,                      Lnodes=Lnodes, Ynodes=Ynodes,                      survivalOutcome=TRUE,                     regimes=sampleDataForLtmleMSM$regimes,                      summary.measures=sampleDataForLtmleMSM$summary.measures[, , 3],                     final.Ynodes=\"Y3\",                      working.msm=\"Y ~ male + switch.time\",                      estimate.time=FALSE) #> Qform not specified, using defaults: #> formula for Y1: #> Q.kplus1 ~ male + age + CD4_0 + A0 #> formula for Y2: #> Q.kplus1 ~ male + age + CD4_0 + A0 + CD4_1 + A1 #> formula for Y3: #> Q.kplus1 ~ male + age + CD4_0 + A0 + CD4_1 + A1 + CD4_2 + A2 #>  #> gform not specified, using defaults: #> formula for A0: #> A0 ~ male + age + CD4_0 #> formula for A1: #> A1 ~ male + age + CD4_0 + A0 + CD4_1 #> formula for A2: #> A2 ~ male + age + CD4_0 + A0 + CD4_1 + A1 + CD4_2 #>  summary(result) #> Estimator:  tmle  #>             Estimate Std. Error  CI 2.5% CI 97.5%  p-value     #> (Intercept) -2.81063    0.46529 -3.72257   -1.899 1.54e-09 *** #> male         0.07357    0.53635 -0.97766    1.125   0.8909     #> switch.time  0.45362    0.19384  0.07370    0.834   0.0193 *   #> --- #> Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1"},{"path":"http://joshuaschwab.github.io/ltmle/articles/a03_msm.html","id":"marginal-structural-models-msms---dynamic-treatment","dir":"Articles","previous_headings":"","what":"Marginal Structural Models (MSMs) - Dynamic Treatment","title":"Marginal Structural Models - ltmleMSM","text":"example two treatment nodes one outcome: W A1 L A2 Y W normally distributed L continuous (0, 1). interested treatments A1 set either 0 1 A2 set dynamically. treatment A2 indexed theta 0 1. \\(L > theta\\), set A2 1, otherwise set A2 0. function can used generate observed data (abar = NULL) generate counterfactual truth (abar list a1 theta): Set regimes summary.measures: Let’s compare true coefficients MSM. First find true value \\(E[Y_{a1, theta}]\\) 5 values theta. Fit working MSM true values \\(E[Y_{a1, theta}]\\). estimated MSM coefficients close true MSM coefficients.","code":"GenerateData <- function(n, abar = NULL) {   W <- rnorm(n)   if (is.null(abar)) {     A1 <- rexpit(W)   } else {     A1 <- abar$a1   }   L <- plogis(rnorm(n) + 0.3 * W + 0.5 * A1)   if (is.null(abar)) {     A2 <- rexpit(-0.5 * W + A1 - 0.6 * L)   } else {     A2 <- as.integer(L > abar$theta)   }   Y <- rexpit(-2 + W + A1 + L + 2 * A2)   if (is.null(abar)) {     return(data.frame(W, A1, L, A2, Y))   } else {     return(mean(Y))   } } set.seed(11) n <- 10000 data <- GenerateData(n) regimes <- array(dim = c(n, 2, 10)) #n x num.Anodes x num.regimes theta.set <- seq(0, 1, length.out = 5) summary.measures <- array(theta.set, dim = c(10, 2, 1)) colnames(summary.measures) <- c(\"a1\", \"theta\") cnt <- 0 for (a1 in 0:1) {   for (theta.index in 1:5) {     cnt <- cnt + 1     regimes[, 1, cnt] <- a1     regimes[, 2, cnt] <- data$L > theta.set[theta.index]     summary.measures[cnt, , 1] <- c(a1, theta.set[theta.index])   } } summary.measures #> , , 1 #>  #>       a1 theta #>  [1,]  0  0.00 #>  [2,]  0  0.25 #>  [3,]  0  0.50 #>  [4,]  0  0.75 #>  [5,]  0  1.00 #>  [6,]  1  0.00 #>  [7,]  1  0.25 #>  [8,]  1  0.50 #>  [9,]  1  0.75 #> [10,]  1  1.00 head(data, 3) #>             W A1          L A2 Y #> 1 -0.59103110  1 0.77137613  1 1 #> 2  0.02659437  0 0.47561600  1 0 #> 3 -1.51655310  0 0.08392365  1 0 regimes[1:3, , ] #> , , 1 #>  #>      [,1] [,2] #> [1,]    0    1 #> [2,]    0    1 #> [3,]    0    1 #>  #> , , 2 #>  #>      [,1] [,2] #> [1,]    0    1 #> [2,]    0    1 #> [3,]    0    0 #>  #> , , 3 #>  #>      [,1] [,2] #> [1,]    0    1 #> [2,]    0    0 #> [3,]    0    0 #>  #> , , 4 #>  #>      [,1] [,2] #> [1,]    0    1 #> [2,]    0    0 #> [3,]    0    0 #>  #> , , 5 #>  #>      [,1] [,2] #> [1,]    0    0 #> [2,]    0    0 #> [3,]    0    0 #>  #> , , 6 #>  #>      [,1] [,2] #> [1,]    1    1 #> [2,]    1    1 #> [3,]    1    1 #>  #> , , 7 #>  #>      [,1] [,2] #> [1,]    1    1 #> [2,]    1    1 #> [3,]    1    0 #>  #> , , 8 #>  #>      [,1] [,2] #> [1,]    1    1 #> [2,]    1    0 #> [3,]    1    0 #>  #> , , 9 #>  #>      [,1] [,2] #> [1,]    1    1 #> [2,]    1    0 #> [3,]    1    0 #>  #> , , 10 #>  #>      [,1] [,2] #> [1,]    1    0 #> [2,]    1    0 #> [3,]    1    0 working.msm <- \"Y ~ a1*theta\" summary(ltmleMSM(data, Anodes = c(\"A1\", \"A2\"), Lnodes = \"L\", Ynodes = \"Y\",                regimes = regimes, summary.measures = summary.measures,                working.msm = working.msm)) #> Qform not specified, using defaults: #> formula for L: #> Q.kplus1 ~ W + A1 #> formula for Y: #> Q.kplus1 ~ W + A1 + L + A2 #>  #> gform not specified, using defaults: #> formula for A1: #> A1 ~ W #> formula for A2: #> A2 ~ W + A1 + L #>  #> Estimate of time to completion: 2 to 4 minutes #> Estimator:  tmle  #>              Estimate Std. Error   CI 2.5% CI 97.5% p-value     #> (Intercept)  0.531670   0.050294  0.433095    0.630  <2e-16 *** #> a1           1.039499   0.074409  0.893660    1.185  <2e-16 *** #> theta       -1.817514   0.071766 -1.958172   -1.677  <2e-16 *** #> a1:theta    -0.006772   0.110068 -0.222502    0.209   0.951     #> --- #> Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1 truth <- rep(NA_real_, 10) cnt <- 0 for (a1 in 0:1) {   for (theta.index in 1:5) {     cnt <- cnt + 1     truth[cnt] <- GenerateData(n = 1e6,                      abar = list(a1 = a1, theta = theta.set[theta.index]))   } } m.true <- glm(working.msm,                data = data.frame(Y = truth, summary.measures[, , 1]),                family = \"quasibinomial\") m.true #>  #> Call:  glm(formula = working.msm, family = \"quasibinomial\", data = data.frame(Y = truth,  #>     summary.measures[, , 1])) #>  #> Coefficients: #> (Intercept)           a1        theta     a1:theta   #>     0.51141      0.96385     -1.75721     -0.03266   #>  #> Degrees of Freedom: 9 Total (i.e. Null);  6 Residual #> Null Deviance:       1.342  #> Residual Deviance: 0.02332   AIC: NA"},{"path":"http://joshuaschwab.github.io/ltmle/articles/a04_deterministic-functions.html","id":"deterministic-g-function","dir":"Articles","previous_headings":"","what":"deterministic.g.function","title":"Deterministic Functions","text":"Time ordering data W, C1, L1, A1, Y1, C2, L2, A2, Y2 True value E[Y_(1,1,1,1)] (expected value Y setting C1, A1, C2, A2 1) approximately 0.413. A1 known always 1 L1 < -2, 1 probability 0.1 L1 > 2 A2 known always 1 A1 1 can incorporate knowledge using deterministic.g.function. Generate data: Without considering deterministic knowledge A1 A2: Now use deterministic.g.function include deterministic knowledge A1 A2:","code":"set.seed(123) rexpit <- function(x) rbinom(n=length(x), size=1, prob=plogis(x)) n <- 1000 ua <- rep(TRUE, n)   #ua = uncensored and alive L1 <- A1 <- Y1 <- C2.binary <- L2 <- A2 <- Y2 <- rep(NA_real_, n) W <- rnorm(n)  C1 <- BinaryToCensoring(is.uncensored=rexpit(2 + W)) ua <- ua & C1 == \"uncensored\" L1[ua] <- rnorm(n)[ua] + W[ua] A1[ua] <- rexpit(L1[ua]) A1[ua & L1 < -2] <- 1 A1[ua & L1 >  2] <- rbinom(n, size=1, prob=0.1)[ua & L1 >  2] Y1[ua] <- rexpit((W + L1 - A1)[ua]) ua <- ua & !Y1  C2.binary[ua] <- rexpit((1 + 0.7 * L1 - A1)[ua]) C2 <- BinaryToCensoring(is.uncensored=C2.binary) ua <- ua & C2 == \"uncensored\" L2[ua] <- (0.5 * L1 - 0.9 * A1 + rnorm(n))[ua] A2[ua] <- rexpit((0.5 * L1 + 0.8 * L2)[ua]) | A1[ua] Y2[ua] <- rexpit((0.7 * L1 + L2 - 0.8 * A1 - A2)[ua]) Y2[Y1 == 1] <- 1  # if a patient dies at time 1, record death at time 2 as well data <- data.frame(W, C1, L1, A1, Y1, C2, L2, A2, Y2) result <- ltmle(data, Anodes=c(\"A1\",\"A2\"), Cnodes=c(\"C1\", \"C2\"),                  Lnodes=c(\"L1\", \"L2\"), Ynodes=c(\"Y1\", \"Y2\"), abar=c(1, 1),                  survivalOutcome=TRUE) #> Qform not specified, using defaults: #> formula for L1: #> Q.kplus1 ~ W #> formula for Y1: #> Q.kplus1 ~ W + L1 + A1 #> formula for L2: #> Q.kplus1 ~ W + L1 + A1 #> formula for Y2: #> Q.kplus1 ~ W + L1 + A1 + L2 + A2 #>  #> gform not specified, using defaults: #> formula for C1: #> C1 ~ W #> formula for A1: #> A1 ~ W + L1 #> formula for C2: #> C2 ~ W + L1 + A1 #> formula for A2: #> A2 ~ W + L1 + A1 + L2 #>  #> Estimate of time to completion: < 1 minute summary(result)  #> Estimator:  tmle  #> Call: #> ltmle(data = data, Anodes = c(\"A1\", \"A2\"), Cnodes = c(\"C1\", \"C2\"),  #>     Lnodes = c(\"L1\", \"L2\"), Ynodes = c(\"Y1\", \"Y2\"), survivalOutcome = TRUE,  #>     abar = c(1, 1)) #>  #>    Parameter Estimate:  0.42358  #>     Estimated Std Err:  0.022199  #>               p-value:  <2e-16  #>     95% Conf Interval: (0.38007, 0.46709) deterministic.g.function <- function(data, current.node, nodes) {   if (names(data)[current.node] == \"A1\") {     det <- (data$L1 < -2 | data$L1 > 2) & !is.na(data$L1)     prob1 <- ((data$L1 < -2) * 1 + (data$L1 > 2) * 0.1)[det]   } else if (names(data)[current.node] == \"A2\") {     det <- data$A1 == 1 & !is.na(data$A1)     prob1 <- 1   } else if (names(data[current.node]) %in% c(\"C1\", \"C2\")){     return(NULL)  #this returns the default of no deterministic links      #note that it is not necessary to specify that prior censoring indicates future censoring   } else {     stop(\"unexpected current.node\")   }   return(list(is.deterministic=det, prob1=prob1))   } result <- ltmle(data, Anodes=c(\"A1\",\"A2\"), Cnodes=c(\"C1\", \"C2\"),                  Lnodes=c(\"L1\", \"L2\"), Ynodes=c(\"Y1\", \"Y2\"), abar=c(1, 1),                  survivalOutcome=TRUE, deterministic.g.function = deterministic.g.function) #> Qform not specified, using defaults: #> formula for L1: #> Q.kplus1 ~ W #> formula for Y1: #> Q.kplus1 ~ W + L1 + A1 #> formula for L2: #> Q.kplus1 ~ W + L1 + A1 #> formula for Y2: #> Q.kplus1 ~ W + L1 + A1 + L2 + A2 #>  #> gform not specified, using defaults: #> formula for C1: #> C1 ~ W #> formula for A1: #> A1 ~ W + L1 #> formula for C2: #> C2 ~ W + L1 + A1 #> formula for A2: #> A2 ~ W + L1 + A1 + L2 #>  #> Estimate of time to completion: < 1 minute summary(result)  #> Estimator:  tmle  #> Call: #> ltmle(data = data, Anodes = c(\"A1\", \"A2\"), Cnodes = c(\"C1\", \"C2\"),  #>     Lnodes = c(\"L1\", \"L2\"), Ynodes = c(\"Y1\", \"Y2\"), survivalOutcome = TRUE,  #>     abar = c(1, 1), deterministic.g.function = deterministic.g.function) #>  #>    Parameter Estimate:  0.42013  #>     Estimated Std Err:  0.026763  #>               p-value:  <2e-16  #>     95% Conf Interval: (0.36768, 0.47259)"},{"path":"http://joshuaschwab.github.io/ltmle/articles/a04_deterministic-functions.html","id":"deterministic-q-function","dir":"Articles","previous_headings":"","what":"deterministic.Q.function","title":"Deterministic Functions","text":"example, L2 positive, patient leaves study consider final outcome 0. W -> A1 -> Y1 -> L2 -> A2 -> Y2 Scenario 1: patients don’t change treatment leaving study; leave A2 NA Specify Q deterministically 0 L2 history current Q regression L2 > 0 necessary specify Q deterministically 1 Y1 1; automatic. Also note det.Q.fun doesn’t condition called..estimate.g g also set deterministically L2 > 0. Scenario 2: treatment can still change patient leaves study","code":"n <- 1000 L2 <- A2 <- Y2 <- as.numeric(rep(NA, n)) W <- rnorm(n) A1 <- rexpit(W) Y1 <- rexpit(W - A1) alive <- Y1 == 0 L2[alive] <- (0.5 * W - 0.9 * A1 + rnorm(n))[alive] completed.study <- alive & L2 > 0 A2[alive & !completed.study] <- rexpit((0.5 * W + 0.8 * L2)[alive & !completed.study])  Y2[alive & !completed.study] <- rexpit((L2 - 0.8 * A1 - A2)[alive & !completed.study]) Y2[alive & completed.study] <- 0 Y2[!alive] <- 1  # if a patient dies at time 1, record death at time 2 as well data <- data.frame(W, A1, Y1, L2, A2, Y2) det.Q.fun.1 <- function(data, current.node, nodes, called.from.estimate.g) {   L2.index <- which(names(data) == \"L2\")   stopifnot(length(L2.index) == 1)   L2.in.history <- L2.index < current.node   if (! L2.in.history) return(NULL)      is.deterministic <- data$L2 > 0 & !is.na(data$L2)   return(list(is.deterministic=is.deterministic, Q.value=0)) }  result.scenario1 <- ltmle(data, Anodes=c(\"A1\",\"A2\"), Lnodes=\"L2\", Ynodes=c(\"Y1\", \"Y2\"), abar=c(1, 1),    SL.library=NULL, estimate.time=FALSE, deterministic.Q.function=det.Q.fun.1, survivalOutcome=TRUE) #> Qform not specified, using defaults: #> formula for Y1: #> Q.kplus1 ~ W + A1 #> formula for Y2: #> Q.kplus1 ~ W + A1 + L2 + A2 #>  #> gform not specified, using defaults: #> formula for A1: #> A1 ~ W #> formula for A2: #> A2 ~ W + A1 + L2 #>  summary(result.scenario1) #> Estimator:  tmle  #> Call: #> ltmle(data = data, Anodes = c(\"A1\", \"A2\"), Lnodes = \"L2\", Ynodes = c(\"Y1\",  #>     \"Y2\"), survivalOutcome = TRUE, abar = c(1, 1), SL.library = NULL,  #>     estimate.time = FALSE, deterministic.Q.function = det.Q.fun.1) #>  #>    Parameter Estimate:  0.33534  #>     Estimated Std Err:  0.02463  #>               p-value:  <2e-16  #>     95% Conf Interval: (0.28707, 0.38361) A2[alive] <- rexpit((0.5 * W + 0.8 * L2)[alive])  #patients can change treatment after leaving study Y2[alive & !completed.study] <- rexpit((L2 - 0.8 * A1 - A2)[alive & !completed.study]) Y2[alive & completed.study] <- 0 Y2[!alive] <- 1  # if a patient dies at time 1, record death at time 2 as well data <- data.frame(W, A1, Y1, L2, A2, Y2)  det.Q.fun.2 <- function(data, current.node, nodes, called.from.estimate.g) {   #there is no deterministic information when calculating g - treatment may still change   if (called.from.estimate.g) return(NULL)        L2.index <- which(names(data) == \"L2\")   stopifnot(length(L2.index) == 1)   L2.in.history <- L2.index < current.node   if (! L2.in.history) return(NULL)      is.deterministic <- data$L2 > 0 & !is.na(data$L2)   return(list(is.deterministic=is.deterministic, Q.value=0)) }  result.scenario2 <- ltmle(data, Anodes=c(\"A1\",\"A2\"), Lnodes=\"L2\", Ynodes=c(\"Y1\", \"Y2\"), abar=c(1, 1),   SL.library=NULL, estimate.time=FALSE, deterministic.Q.function=det.Q.fun.2, survivalOutcome=TRUE) #> Qform not specified, using defaults: #> formula for Y1: #> Q.kplus1 ~ W + A1 #> formula for Y2: #> Q.kplus1 ~ W + A1 + L2 + A2 #>  #> gform not specified, using defaults: #> formula for A1: #> A1 ~ W #> formula for A2: #> A2 ~ W + A1 + L2 #>  #> Warning in CheckForVarianceWarning(inputs, g.ratio): Variance estimate is based #> on influence curve only, which may be significantly anticonservative because #> your data appears to contain positivity violations. Robust variance estimate is #> not currently available with deterministic.Q.function but this will be #> addressed in a future release. summary(result.scenario2) #> Estimator:  tmle  #> Call: #> ltmle(data = data, Anodes = c(\"A1\", \"A2\"), Lnodes = \"L2\", Ynodes = c(\"Y1\",  #>     \"Y2\"), survivalOutcome = TRUE, abar = c(1, 1), SL.library = NULL,  #>     estimate.time = FALSE, deterministic.Q.function = det.Q.fun.2) #>  #>    Parameter Estimate:  0.3223  #>     Estimated Std Err:  0.023814  #>               p-value:  <2e-16  #>     95% Conf Interval: (0.27562, 0.36897)"},{"path":"http://joshuaschwab.github.io/ltmle/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Joshua Schwab. Author, maintainer. Samuel Lendle. Author. Maya Petersen. Author. Mark van der Laan. Author. Susan Gruber. Contributor.","code":""},{"path":"http://joshuaschwab.github.io/ltmle/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Lendle SD, Schwab J, Petersen ML, van der Laan MJ (2017). “ltmle: R Package Implementing Targeted Minimum Loss-Based Estimation Longitudinal Data.” Journal Statistical Software, 81(1), 1–21. doi:10.18637/jss.v081.i01.","code":"@Article{,   title = {{ltmle}: An {R} Package Implementing Targeted Minimum Loss-Based Estimation for Longitudinal Data},   author = {Samuel D. Lendle and Joshua Schwab and Maya L. Petersen and Mark J. {van der Laan}},   journal = {Journal of Statistical Software},   year = {2017},   volume = {81},   number = {1},   pages = {1--21},   doi = {10.18637/jss.v081.i01}, }"},{"path":"http://joshuaschwab.github.io/ltmle/index.html","id":"ltmle","dir":"","previous_headings":"","what":"Longitudinal Targeted Maximum Likelihood Estimation","title":"Longitudinal Targeted Maximum Likelihood Estimation","text":"Longitudinal Targeted Maximum Likelihood Estimation package See Articles section examples","code":""},{"path":"http://joshuaschwab.github.io/ltmle/reference/BinaryToCensoring.html","id":null,"dir":"Reference","previous_headings":"","what":"BinaryToCensoring — BinaryToCensoring","title":"BinaryToCensoring — BinaryToCensoring","text":"Helper function creating censoring columns factors.","code":""},{"path":"http://joshuaschwab.github.io/ltmle/reference/BinaryToCensoring.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"BinaryToCensoring — BinaryToCensoring","text":"","code":"BinaryToCensoring(is.censored, is.uncensored)"},{"path":"http://joshuaschwab.github.io/ltmle/reference/BinaryToCensoring.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"BinaryToCensoring — BinaryToCensoring","text":".censored binary vector: 0=uncensored, 1=censored .uncensored binary vector: 0=censored, 1=uncensored","code":""},{"path":"http://joshuaschwab.github.io/ltmle/reference/BinaryToCensoring.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"BinaryToCensoring — BinaryToCensoring","text":"object class \"factor\" levels \"censored\" \"uncensored\"","code":""},{"path":"http://joshuaschwab.github.io/ltmle/reference/BinaryToCensoring.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"BinaryToCensoring — BinaryToCensoring","text":"Exactly one .censored .uncensored must specified named argument.  elements input vector must 0, 1, NA","code":""},{"path":[]},{"path":"http://joshuaschwab.github.io/ltmle/reference/BinaryToCensoring.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"BinaryToCensoring — BinaryToCensoring","text":"Joshua Schwab jschwab77@berkeley.edu","code":""},{"path":"http://joshuaschwab.github.io/ltmle/reference/BinaryToCensoring.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"BinaryToCensoring — BinaryToCensoring","text":"","code":"BinaryToCensoring(is.censored=c(0, 1, 1, 0, NA)) #> [1] uncensored censored   censored   uncensored <NA>       #> Levels: censored uncensored  BinaryToCensoring(is.uncensored=c(1, 0, 0, 1, NA))   #the same #> [1] uncensored censored   censored   uncensored <NA>       #> Levels: censored uncensored    if (FALSE) {  BinaryToCensoring(c(0, 1))   #error because the input must be named  }"},{"path":"http://joshuaschwab.github.io/ltmle/reference/deterministic.g.function_template.html","id":null,"dir":"Reference","previous_headings":"","what":"Deterministic g/Q functions - examples and templates — deterministic.g.function_template","title":"Deterministic g/Q functions - examples and templates — deterministic.g.function_template","text":"Template deterministic.g.function  argument ltmle ltmleMSM.","code":""},{"path":"http://joshuaschwab.github.io/ltmle/reference/deterministic.g.function_template.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Deterministic g/Q functions - examples and templates — deterministic.g.function_template","text":"","code":"deterministic.g.function_template(data, current.node, nodes)  deterministic.Q.function_template(   data,   current.node,   nodes,   called.from.estimate.g )"},{"path":"http://joshuaschwab.github.io/ltmle/reference/deterministic.g.function_template.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Deterministic g/Q functions - examples and templates — deterministic.g.function_template","text":"data 'data' data.frame passed ltmle ltmleMSM current.node column index data corresponding C node (g) L Y node (Q) nodes list column indicies, components: Anodes (treatment) C Cnodes (censoring) L Lnodes (time-varying covariates) Y Ynodes (events) AC Anodes Cnodes combined sorted LY Lnodes Ynodes combined, sorted, \"blocks\" removed - see ltmle called..estimate.g TRUE FALSE - function called called..estimate.g=TRUE estimation g called..estimate.g=FALSE estimation Q.","code":""},{"path":"http://joshuaschwab.github.io/ltmle/reference/deterministic.g.function_template.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Deterministic g/Q functions - examples and templates — deterministic.g.function_template","text":"deterministic.g.function return list components: .deterministic vector logicals, length=nrow(data) prob1 probability data[.deterministic, current.node] == 1, vector length 1 length((.deterministic)) deterministic.Q.function return list components: .deterministic vector logicals, length=nrow(data) Q.value iterated expectation final Y, vector length 1 length((.deterministic)) NOTE: Q.value component used required called..estimate.g TRUE","code":""},{"path":"http://joshuaschwab.github.io/ltmle/reference/deterministic.g.function_template.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Deterministic g/Q functions - examples and templates — deterministic.g.function_template","text":"MaintainTreatment MaintainControl two commonly used deterministic.g.functions. intended use templates user copy paste function arguments body fill required sections. run -. Note comments functions saved. Versions comments may found Examples section . MaintainTreatment MaintainControl may passed -deterministic.g.function argument ltmle ltmleMSM Note censoring nodes data may passed binaries converted preferred format factors levels \"censored\" \"uncensored\" deterministic functions called.  Also note nodes may passed ltmle either names nodes numerical column indicies, converted numerical indicies deterministic functions called.  survivalFunction argument ltmle ltmleMSM TRUE, package automatically assumes Y jumps 1, future Y nodes stay 1 treatment change. necessary specify deterministic functions.","code":""},{"path":"http://joshuaschwab.github.io/ltmle/reference/deterministic.g.function_template.html","id":"functions","dir":"Reference","previous_headings":"","what":"Functions","title":"Deterministic g/Q functions - examples and templates — deterministic.g.function_template","text":"deterministic.Q.function_template(): Template deterministic.Q.function  argument ltmle ltmleMSM.","code":""},{"path":[]},{"path":"http://joshuaschwab.github.io/ltmle/reference/deterministic.g.function_template.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Deterministic g/Q functions - examples and templates — deterministic.g.function_template","text":"Joshua Schwab jschwab77@berkeley.edu","code":""},{"path":"http://joshuaschwab.github.io/ltmle/reference/deterministic.g.function_template.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Deterministic g/Q functions - examples and templates — deterministic.g.function_template","text":"","code":"# Show template for a deterministic.g.function (comments will not be # shown, see below for comments) deterministic.g.function_template #> function (data, current.node, nodes)  #> { #>     is.deterministic <- stop(\"replace me!\") #>     prob1 <- stop(\"replace me!\") #>     return(list(is.deterministic = is.deterministic, prob1 = prob1)) #> } #> <bytecode: 0x55c04aae9e80> #> <environment: namespace:ltmle>  # Show template for a deterministic.Q.function (comments will not be # shown, see below for comments) deterministic.Q.function_template #> function (data, current.node, nodes, called.from.estimate.g)  #> { #>     is.deterministic <- stop(\"replace me!\") #>     Q.value <- stop(\"replace me!\") #>     return(list(is.deterministic = is.deterministic, Q.value = Q.value)) #> } #> <bytecode: 0x55c0493796e8> #> <environment: namespace:ltmle>  # Use MaintainTreatment set.seed(1) rexpit <- function(x) rbinom(n = length(x), size = 1, prob = plogis(x)) n <- 100 W <- rnorm(n) A1 <- rexpit(W) A2 <- as.numeric(rexpit(W) | A1)  #treatment at time 1 implies treatment at time 2 Y <- rexpit(W + A1 + A2 + rnorm(n)) data <- data.frame(W, A1, A2, Y)  result <- ltmle(data, Anodes = c(\"A1\", \"A2\"), Ynodes = \"Y\", abar = c(1, 1),      deterministic.g.function = MaintainTreatment) #> Qform not specified, using defaults: #> formula for Y: #> Q.kplus1 ~ W + A1 + A2 #>  #> gform not specified, using defaults: #> formula for A1: #> A1 ~ W #> formula for A2: #> A2 ~ W + A1 #>  #> Estimate of time to completion: < 1 minute  # deterministic.g.function_template with comments:  deterministic.g.function_template <- function(data, current.node, nodes) {     # data: the 'data' data.frame passed to ltmle/ltmleMSM current.node: the     # column index of data corresponding to the A or C node (see     # is.deterministic below) nodes: list of column indicies, components: A,     # C, L, Y, AC (Anodes and Cnodes combined and sorted), LY (Lnodes and     # Ynodes combined, sorted, 'blocks' removed - see ?ltmle) Note that nodes     # may be passed to ltmle as either the names of nodes or numerical column     # indicies, but they are all converted to numerical indicies before     # deterministic.g.function is called          # deterministic.g.function will be called at all Anodes and Cnodes     # return(NULL) is equivalent to return(list(is.deterministic=rep(FALSE,     # nrow(data)), prob1=numeric(0)))          # define is.deterministic here: vector of logicals, length=nrow(data)     # define prob1 here: the probability that data[is.deterministic,     # current.node] == 1, vector of length 1 or     # length(which(is.deterministic))     is.deterministic <- stop(\"replace me!\")     prob1 <- stop(\"replace me!\")     return(list(is.deterministic = is.deterministic, prob1 = prob1)) }  # deterministic.Q.function_template with comments:  deterministic.Q.function_template <- function(data, current.node, nodes,      called.from.estimate.g) {     # data: the 'data' data.frame passed to ltmle/ltmleMSM current.node: the     # column index of data corresponding to the A or C node (see     # is.deterministic below) nodes: list of column indicies, components: A,     # C, L, Y, AC (Anodes and Cnodes combined and sorted), LY (Lnodes and     # Ynodes combined, sorted, 'blocks' removed - see ?ltmle)     # called.from.estimate.g: TRUE or FALSE - your function will be called     # with called.from.estimate.g=TRUE during estimation of g and     # called.from.estimate.g=FALSE during estimation of Q. During estimation     # of g, only the is.deterministic element of the return list will be     # used.  Note that nodes may be passed to ltmle as either the names of     # nodes or numerical column indicies, but they are all converted to     # numerical indicies before deterministic.Q.function is called          # It is not necessary to specify that deterministic Y events (Y==1)     # indicate a deterministic Q value of 1; this is automatic      # if the survivalFunction input to ltmle/ltmleMSM is TRUE.     # deterministic.Q.function will be called at all Lnodes and Ynodes (after     # removing 'blocks') and Anodes and Cnodes (see called.from.estimate.g     # above) return(NULL) is equivalent to     # return(list(is.deterministic=rep(FALSE, nrow(data)),     # Q.value=numeric(0)))          # define is.deterministic here: vector of logicals, length=nrow(data)     # define Q.value here: the iterated expectation of the final Y, vector of     # length 1 or length(which(is.deterministic))     is.deterministic <- stop(\"replace me!\")     Q.value <- stop(\"replace me!\")     return(list(is.deterministic = is.deterministic, Q.value = Q.value)) }"},{"path":"http://joshuaschwab.github.io/ltmle/reference/ltmle-package.html","id":null,"dir":"Reference","previous_headings":"","what":"Targeted Maximum Likelihood Estimation for Longitudinal Data — ltmle-package","title":"Targeted Maximum Likelihood Estimation for Longitudinal Data — ltmle-package","text":"Targeted Maximum Likelihood Estimation (TMLE) treatment/censoring specific mean outcome marginal structural model point-treatment longitudinal data. Also provides Inverse Probability Treatment/Censoring Weighted estimate (IPTW) maximum likelihood based G-computation estimate (G-comp). Can used calculate additive treatment effect, risk ratio, odds ratio.","code":""},{"path":"http://joshuaschwab.github.io/ltmle/reference/ltmle-package.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Targeted Maximum Likelihood Estimation for Longitudinal Data — ltmle-package","text":"Bang, Heejung, James M. Robins. \"Doubly robust estimation missing data causal inference models.\" Biometrics 61.4 (2005): 962-973. Lendle SD, Schwab J, Petersen ML van der Laan MJ (2017). \"ltmle: R Package Implementing Targeted Minimum Loss-Based Estimation Longitudinal Data.\" _Journal Statistical Software_, *81*(1), pp. # ' 1-21. doi: 10.18637/jss.v081.i01  doi:10.18637/jss.v081.i01 Petersen, Maya, Schwab, Joshua van der Laan, Mark J, \"Targeted Maximum Likelihood Estimation Marginal Structural Working Models Dynamic Treatments Time-Dependent Outcomes\", Journal Causal Inference, 2014 https://pubmed.ncbi.nlm.nih.gov/25909047/ Robins JM, Sued M, Lei-Gomez Q, Rotnitsky . (2007). Comment: Performance double-robust estimators Inverse Probability weights highly variable. Statistical Science 22(4):544-559. van der Laan, Mark J. Gruber, Susan, \"Targeted Minimum Loss Based Estimation Intervention Specific Mean Outcome\" (August 2011). U.C. Berkeley Division Biostatistics Working Paper Series. Working Paper 290. https://biostats.bepress.com/ucbbiostat/paper290/ van der Laan, Mark J. Rose, Sherri, \"Targeted Learning: Causal Inference Observational Experimental Data\" New York: Springer, 2011.","code":""},{"path":[]},{"path":"http://joshuaschwab.github.io/ltmle/reference/ltmle-package.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Targeted Maximum Likelihood Estimation for Longitudinal Data — ltmle-package","text":"Joshua Schwab, Samuel Lendle, Maya Petersen, Mark van der Laan, contributions Susan Gruber Maintainer: Joshua Schwab jschwab77@berkeley.edu","code":""},{"path":"http://joshuaschwab.github.io/ltmle/reference/ltmle-package.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Targeted Maximum Likelihood Estimation for Longitudinal Data — ltmle-package","text":"","code":"## For examples see examples(ltmle) and \\url{http://joshuaschwab.github.io/ltmle/}"},{"path":"http://joshuaschwab.github.io/ltmle/reference/ltmle.html","id":null,"dir":"Reference","previous_headings":"","what":"Longitudinal Targeted Maximum Likelihood Estimation — ltmle","title":"Longitudinal Targeted Maximum Likelihood Estimation — ltmle","text":"ltmle Targeted Maximum Likelihood Estimation (TMLE) treatment/censoring specific mean outcome point-treatment longitudinal data. ltmleMSM adds Marginal Structural Models. always provide Inverse Probability Treatment/Censoring Weighted estimate (IPTW) well. Maximum likelihood based G-computation estimate (G-comp) can obtained instead TMLE. ltmle can used calculate additive treatment effect, risk ratio, odds ratio.","code":""},{"path":"http://joshuaschwab.github.io/ltmle/reference/ltmle.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Longitudinal Targeted Maximum Likelihood Estimation — ltmle","text":"","code":"ltmle(   data,   Anodes,   Cnodes = NULL,   Lnodes = NULL,   Ynodes,   survivalOutcome = NULL,   Qform = NULL,   gform = NULL,   abar,   rule = NULL,   gbounds = c(0.01, 1),   Yrange = NULL,   deterministic.g.function = NULL,   stratify = FALSE,   SL.library = \"glm\",   SL.cvControl = list(),   estimate.time = TRUE,   gcomp = FALSE,   iptw.only = FALSE,   deterministic.Q.function = NULL,   variance.method = \"tmle\",   observation.weights = NULL,   id = NULL )  ltmleMSM(   data,   Anodes,   Cnodes = NULL,   Lnodes = NULL,   Ynodes,   survivalOutcome = NULL,   Qform = NULL,   gform = NULL,   gbounds = c(0.01, 1),   Yrange = NULL,   deterministic.g.function = NULL,   SL.library = \"glm\",   SL.cvControl = list(),   regimes,   working.msm,   summary.measures,   final.Ynodes = NULL,   stratify = FALSE,   msm.weights = \"empirical\",   estimate.time = TRUE,   gcomp = FALSE,   iptw.only = FALSE,   deterministic.Q.function = NULL,   variance.method = \"tmle\",   observation.weights = NULL,   id = NULL )"},{"path":"http://joshuaschwab.github.io/ltmle/reference/ltmle.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Longitudinal Targeted Maximum Likelihood Estimation — ltmle","text":"data data frame following time-ordering nodes. See 'Details'. Anodes column names indicies data treatment nodes Cnodes column names indicies data censoring nodes Lnodes column names indicies data time-dependent covariate nodes Ynodes column names indicies data outcome nodes survivalOutcome TRUE, Y nodes indicators event, Y time point 1, following 1. Required TRUE FALSE outcomes binary multiple Ynodes. Qform character vector regression formulas \\(Q\\). See 'Details'. gform character vector regression formulas \\(g\\) matrix/array prob(=1). See 'Details'. abar binary vector (numAnodes x 1) matrix (n x numAnodes) counterfactual treatment list length 2. See 'Details'. rule function applied row (named vector) data returns numeric vector length numAnodes. See 'Details'. gbounds lower upper bounds estimated cumulative probabilities g-factors. Vector length 2, order unimportant. Yrange NULL numerical vector min max Yrange specify range Y nodes. See 'Details'. deterministic.g.function optional information C nodes given deterministically. See 'Details'. Default NULL indicates deterministic links. stratify TRUE stratify following abar estimating Q g. FALSE, pool abar. SL.library optional character vector libraries pass SuperLearner. NULL indicates glm called instead SuperLearner. 'default' indicates standard set libraries. May separately specified \\(Q\\) \\(g\\). See 'Details'. SL.cvControl optional list passed cvControl SuperLearner estimate.time TRUE, run initial estimate using 50 observations use print rough estimate total time completion. action fewer 50 observations. gcomp TRUE, run maximum likelihood based G-computation estimate instead TMLE iptw.default (iptw.= FALSE), TMLE IPTW run ltmle ltmleMSM. iptw.= TRUE, IPTW run, faster. deterministic.Q.function optional information Q given deterministically. See 'Details'. Default NULL indicates deterministic links. variance.method Method estimating variance TMLE. One \"ic\", \"tmle\", \"iptw\". \"tmle\", compute robust variance estimate using TMLE influence curve based variance estimate (use larger two). \"iptw\", compute robust variance estimate using IPTW influence curve based variance estimate (use larger two). \"ic\", compute influence curve based variance estimate. \"ic\" fastest, may substantially anti-conservative positivity violations rare outcomes. \"tmle\" slowest robust positivity violations rare outcomes. \"iptw\" compromise speed robustness. variance.method=\"tmle\" \"iptw\" yet available non-binary outcomes, gcomp=TRUE, stratify=TRUE, deterministic.Q.function. observation.weights observation (sampling) weights. Vector length n. NULL, assumed 1. id Household subject identifiers. Vector length n NULL. Integer, factor, character recommended, type can coerced factor work. NULL means distinct ids. regimes binary array: n x numAnodes x numRegimes counterfactual treatment list 'rule' functions working.msm character formula working marginal structural model summary.measures array: num.regimes x num.summary.measures x num.final.Ynodes - measures summarizing regimes used right hand side working.msm (baseline covariates may also used right hand side working.msm need included summary.measures) final.Ynodes vector subset Ynodes - used MSM pool set outcome nodes msm.weights projection weights working MSM. \"empirical\", weight empirical proportions rows matching regime final.Ynode, duplicate regimes given zero weight. NULL, weights. array user-supplied weights dimensions c(n, num.regimes, num.final.Ynodes) c(num.regimes, num.final.Ynodes).","code":""},{"path":"http://joshuaschwab.github.io/ltmle/reference/ltmle.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Longitudinal Targeted Maximum Likelihood Estimation — ltmle","text":"ltmle returns object class \"ltmle\" (unless abar rule list, case returns object class ltmleSummaryMeasures, components ltmleMSM.) function summary (.e. summary.ltmle) can used obtain print summary results. object class \"ltmle\" list containing following components: estimates named vector length 4 elements, estimate \\(E[Y_{bar{}}]\\): tmle - Targeted Maximum Likelihood Estimate [NULL gcomp TRUE] iptw - Inverse Probability Treatment/Censoring Weighted estimate gcomp - maximum likelihood based G-computation estimate [NULL gcomp FALSE]  IC list following components Influence Curve values tmle - vector influence curve values Targeted Maximum Likelihood Estimate [NULL gcomp TRUE] iptw - vector influence curve values Inverse Probability Treatment/Censoring Weighted estimate gcomp - vector influence curve values Targeted Maximum Likelihood Estimate without updating [NULL gcomp FALSE] cum.g cumulative g, bounding: ltmle, n x numACnodes, ltmleMSM, n x numACnodes x num.regimes cum.g.unbounded cumulative g, bounding: ltmle, n x numACnodes, ltmleMSM, n x numACnodes x num.regimes cum.g.used binary - TRUE entry cum.g used updating step (note: even cum.g.used FALSE, small value cum.g.unbounded may still indicate positivity problem): ltmle, n x numACnodes, ltmleMSM, n x numACnodes x num.regimes call matched call gcomp gcomp input formulas list elements Qform gform fit list following components g - list length numACnodes - glm SuperLearner (see Details) return objects fitting g regressions Q - list length numLYnodes - glm SuperLearner (see Details) return objects fitting Q regressions Qstar - list length numLYnodes - glm (numerical optimization glm fails solve score equation) return objects updating Q fit ltmleMSM returns object class \"ltmleMSM\" function summary (.e. summary.ltmleMSM) can used obtain print summary results. object class \"ltmleMSM\" list containing following components: beta parameter estimates working.msm using TMLE (GCOMP gcomp input TRUE) beta.iptw parameter estimates working.msm using IPTW IC matrix, n x numBetas - influence curve values TMLE (without updating gcomp input TRUE) IC.iptw matrix, n x numBetas - influence curve values IPTW msm object class glm - result fitting working.msm cum.g array, n x numACnodes x numRegimes - cumulative g, bounding cum.g.unbounded array, n x numACnodes x numRegimes - cumulative g, bounding call matched call gcomp gcomp input formulas list elements Qform gform fit list following components g - list length numRegimes list length numACnodes - glm SuperLearner (see Details) return objects fitting g regressions Q - list length numLYnodes - glm SuperLearner (see Details) return objects fitting Q regressions Qstar - list length numLYnodes - glm (numerical optimization glm fails solve score equation) return objects updating Q fit","code":""},{"path":"http://joshuaschwab.github.io/ltmle/reference/ltmle.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Longitudinal Targeted Maximum Likelihood Estimation — ltmle","text":"estimates returned ltmle treatment specific mean, \\(E[Y_{\\bar{}}]\\), mean final treatment node, treatment nodes, \\(\\), set \\(\\bar{}\\) (abar) censoring nodes \\(C\\) set 1 (uncensored). estimates returned ltmleMSM similar parameters working marginal structural model. data data frame order columns corresponds time-ordering model. censoring columns (Cnodes): factor two levels: \"censored\" \"uncensored\". helper function BinaryToCensoring can used create factors. treatment columns (Anodes): 1 = treated, 0 = untreated (must binary) event columns (Ynodes): survivalOutcome TRUE, Y nodes treated indicators one-time event. See details survivalOutocme. survivalOutcome FALSE, Y nodes treated binary values 0 1, treated continuous otherwise. Y nodes continuous, may automatically scaled. See details Yrange. time-dependent covariate columns (Lnodes): can numeric data Data Cnodes, Anodes, Lnodes Ynodes used (right ) censoring (event survivalOutcome==TRUE) may coded NA value. Columns data (left ) first Cnodes Anodes treated baseline variables, even specified Lnodes. first Cnodes, Anodes, Ynodes, Lnodes, every column must one Cnodes, Anodes, Ynodes, Lnodes. survivalOutcome TRUE, Y values indicators event (e.g. death) current time, 1 = event 0 = event. events Ynodes must form Y jumps 1, Y remains 1 subsequent nodes. continuous outcomes, (survivalOutcome==FALSE Y nodes 0 1,) Y values truncated minimum maximum Yrange specified, transformed scaled [0,1]. , transformed (Y-min(Yrange))/(max(Yrange)-min(Yrange)). Yrange NULL, set range Y nodes. case, Y nodes scaled values fall outside [0,1]. intervention specific means (ltmle), parameter estimates transformed back based Yrange. Qform NULL, case parent nodes L Y node used regressors, named character vector can coerced class \"formula\". length Qform must equal length(Lnodes) + length(Ynodes)** names order formulas must names order L Y nodes data. left hand side formula \"Q.kplus1\". SL.library NULL, glm called using elements Qform. SL.library specified, SuperLearner called design matrix created using Qform. ** \"block\" L Y nodes separated C nodes, one regression required first L/Y node block. can pass regression formulas L/Y nodes, ignored (message). See example 5. gform NULL, case parent nodes L Y node used regressors, character vector can coerced class \"formula\", matrix/array Prob(=1). gform character vector, length gform must equal length(Anodes) + length(Cnodes) order formulas must order C nodes appear data. left hand side formula name Anode Cnode. SL.library NULL, glm called using elements gform. SL.library specified, SuperLearner called design matrix created using gform. ltmle, gform can also n x numACnodes matrix entry (, j) probability ith observation jth /C node 1 (Anode) uncensored (Cnode), conditional following abar node. ltmleMSM, gform can similarly n x numACnodes x numRegimes array, entry (, j, k) probability ith observation jth /C node 1 (Anode) uncensored (Cnode), conditional following regime k node. gform matrix/array, deterministic.g.function used NULL. abar specifies counterfactual values Anodes, using order appear data length (abar vector) number columns (abar matrix) Anodes. rule can used specify dynamic treatment rule. rule function applied row data returns numeric vector length Anodes. abar rule specified. one list length 2, additive treatment effect, risk ratio, odds ratio can computed using summary.ltmleEffectMeasures. regimes can binary array: n x numAnodes x numRegimes counterfactual treatment list 'rule' functions described rule argument ltmle function deterministic.g.function can function used specify model knowledge value Anodes /Cnodes set deterministically. example, may case patient starts treatment, always stay treatment. details form function examples, see deterministic.g.function_template deterministic.Q.function can function used specify model knowledge final event state. example, may case patient can complete study intermediate time point, case probability death 0 (assuming died already). details form function examples, see deterministic.Q.function_template SL.library may character vector libraries ('glm' 'default'), case libraries used estimate \\(Q\\) \\(g\\) list two components, Q g, character vector libraries ('glm' 'default').  'glm' indicates glm called instead SuperLearner SL.library string 'default', SL.library set list(\"SL.glm\", \"SL.stepAIC\", \"SL.bayesglm\", c(\"SL.glm\", \"screen.corP\"), c(\"SL.step\", \"screen.corP\"), c(\"SL.step.forward\", \"screen.corP\"), c(\"SL.stepAIC\", \"screen.corP\"), c(\"SL.step.interaction\", \"screen.corP\"), c(\"SL.bayesglm\", \"screen.corP\").  Note default set libraries consists main terms models. may advisable include squared terms, interaction terms, etc gform Qform include libraries consider non-linear terms. attr(SL.library, \"return.fit\") == TRUE, fit$g fit$Q return full SuperLearner glm objects. , summary matrix returned save memory. print method ltmle objects prints tmle estimates.","code":""},{"path":"http://joshuaschwab.github.io/ltmle/reference/ltmle.html","id":"functions","dir":"Reference","previous_headings":"","what":"Functions","title":"Longitudinal Targeted Maximum Likelihood Estimation — ltmle","text":"ltmleMSM(): Longitudinal Targeted Maximum Likelihood Estimation Marginal Structural Model","code":""},{"path":[]},{"path":"http://joshuaschwab.github.io/ltmle/reference/ltmle.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Longitudinal Targeted Maximum Likelihood Estimation — ltmle","text":"Joshua Schwab jschwab77@berkeley.edu, Samuel Lendle, Maya Petersen, Mark van der Laan","code":""},{"path":"http://joshuaschwab.github.io/ltmle/reference/ltmle.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Longitudinal Targeted Maximum Likelihood Estimation — ltmle","text":"","code":"# See \\url{http://joshuaschwab.github.io/ltmle/} for more examples.  rexpit <- function(x) rbinom(n=length(x), size=1, prob=plogis(x))  # Single time point Example n <- 1000 W <- rnorm(n) A <- rexpit(-1 + 2 * W) Y <- rexpit(W + A) data <- data.frame(W, A, Y)  result1 <- ltmle(data, Anodes=\"A\", Ynodes=\"Y\", abar=1) #> Qform not specified, using defaults: #> formula for Y: #> Q.kplus1 ~ W + A #>  #> gform not specified, using defaults: #> formula for A: #> A ~ W #>  #> Estimate of time to completion: < 1 minute summary(result1) #> Estimator:  tmle  #> Call: #> ltmle(data = data, Anodes = \"A\", Ynodes = \"Y\", abar = 1) #>  #>    Parameter Estimate:  0.70148  #>     Estimated Std Err:  0.050825  #>               p-value:  <2e-16  #>     95% Conf Interval: (0.60186, 0.8011)  #>  summary(result1, estimator=\"iptw\") #> Estimator:  iptw  #> Call: #> ltmle(data = data, Anodes = \"A\", Ynodes = \"Y\", abar = 1) #>  #>    Parameter Estimate:  0.67206  #>     Estimated Std Err:  0.081852  #>               p-value:  2.1996e-16  #>     95% Conf Interval: (0.51163, 0.83248)  #>  # MSM Example # Given data over 3 time points where A switches to 1 once and then stays 1. We want to know # how death varies as a function of gender, time and an indicator of whether a patient's # intended regime was to switch before time. # Note that working.msm includes time and switch.time, which are columns of # summary.measures; working.msm also includes male, which is ok because it is a baseline # covariate (it comes before any A/C/L/Y nodes). data(sampleDataForLtmleMSM) Anodes <- grep(\"^A\", names(sampleDataForLtmleMSM$data)) Lnodes <- c(\"CD4_1\", \"CD4_2\") Ynodes <- grep(\"^Y\", names(sampleDataForLtmleMSM$data)) msm.weights <- matrix(1:12, nrow=4, ncol=3) #just an example (can also use a 200x3x4 array),                                             #or NULL (for no weights), or \"empirical\" (the default)  result2 <- ltmleMSM(sampleDataForLtmleMSM$data, Anodes=Anodes, Lnodes=Lnodes, Ynodes=Ynodes,                    survivalOutcome=TRUE,                    regimes=sampleDataForLtmleMSM$regimes,                    summary.measures=sampleDataForLtmleMSM$summary.measures, final.Ynodes=Ynodes,                    working.msm=\"Y ~ male + time + I(pmax(time - switch.time, 0))\",                    msm.weights=msm.weights, estimate.time=FALSE) #> Qform not specified, using defaults: #> formula for Y1: #> Q.kplus1 ~ male + age + CD4_0 + A0 #> formula for Y2: #> Q.kplus1 ~ male + age + CD4_0 + A0 + CD4_1 + A1 #> formula for Y3: #> Q.kplus1 ~ male + age + CD4_0 + A0 + CD4_1 + A1 + CD4_2 + A2 #>  #> gform not specified, using defaults: #> formula for A0: #> A0 ~ male + age + CD4_0 #> formula for A1: #> A1 ~ male + age + CD4_0 + A0 + CD4_1 #> formula for A2: #> A2 ~ male + age + CD4_0 + A0 + CD4_1 + A1 + CD4_2 #>  print(summary(result2)) #> Estimator:  tmle  #>                                Estimate Std. Error CI 2.5% CI 97.5%  p-value #> (Intercept)                     -3.4059     0.6545 -4.6886   -2.123 1.95e-07 #> male                            -0.3802     0.5305 -1.4198    0.660  0.47360 #> time                             0.7241     0.2602  0.2141    1.234  0.00539 #> I(pmax(time - switch.time, 0))  -0.4717     0.2019 -0.8675   -0.076  0.01948 #>                                    #> (Intercept)                    *** #> male                               #> time                           **  #> I(pmax(time - switch.time, 0)) *   #> --- #> Signif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1"},{"path":"http://joshuaschwab.github.io/ltmle/reference/sampleDataForLtmleMSM.html","id":null,"dir":"Reference","previous_headings":"","what":"Sample data, regimes, and summary measures — sampleDataForLtmleMSM","title":"Sample data, regimes, and summary measures — sampleDataForLtmleMSM","text":"Sample data use ltmleMSM. Data: n=1000: male age CD4_1 A1 Y1 CD4_2 A2 Y2 CD4_3 A3 Y3 A1..A3 treatment nodes, Y1..Y3 death, CD4_1..CD4_3 time varying covariates. interested static regimes patient switches time. summary.measures, switch.time first time 1 (4 never switch), time horizon.","code":""},{"path":"http://joshuaschwab.github.io/ltmle/reference/sampleDataForLtmleMSM.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Sample data, regimes, and summary measures — sampleDataForLtmleMSM","text":"List three components: data, regimes, summary.measures","code":""},{"path":"http://joshuaschwab.github.io/ltmle/reference/sampleDataForLtmleMSM.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"Sample data, regimes, and summary measures — sampleDataForLtmleMSM","text":"simulated data","code":""},{"path":"http://joshuaschwab.github.io/ltmle/reference/sampleDataForLtmleMSM.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Sample data, regimes, and summary measures — sampleDataForLtmleMSM","text":"regimes: 200 x 3 x 4 [n x numACnodes x numRegimes] summary.measures: 4 x 2 x 3 [numRegimes x numSummaryMeasures x numFinalYnodes]","code":""},{"path":"http://joshuaschwab.github.io/ltmle/reference/sampleDataForLtmleMSM.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Sample data, regimes, and summary measures — sampleDataForLtmleMSM","text":"","code":"data(sampleDataForLtmleMSM)"},{"path":"http://joshuaschwab.github.io/ltmle/reference/summary.ltmle.html","id":null,"dir":"Reference","previous_headings":"","what":"Get standard error, p-value, and confidence interval for one ltmle object\nSummarizing results from Longitudinal Targeted Maximum Likelihood Estimation\n(ltmle) — summary.ltmle","title":"Get standard error, p-value, and confidence interval for one ltmle object\nSummarizing results from Longitudinal Targeted Maximum Likelihood Estimation\n(ltmle) — summary.ltmle","text":"functions methods class ltmle summary.ltmle objects.","code":""},{"path":"http://joshuaschwab.github.io/ltmle/reference/summary.ltmle.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get standard error, p-value, and confidence interval for one ltmle object\nSummarizing results from Longitudinal Targeted Maximum Likelihood Estimation\n(ltmle) — summary.ltmle","text":"","code":"# S3 method for ltmle summary(object, estimator = ifelse(object$gcomp, \"gcomp\", \"tmle\"), ...)  # S3 method for ltmleEffectMeasures summary(object, estimator = ifelse(object$gcomp, \"gcomp\", \"tmle\"), ...)  # S3 method for ltmleMSM summary(object, estimator = ifelse(object$gcomp, \"gcomp\", \"tmle\"), ...)  # S3 method for summary.ltmleMSM print(   x,   digits = max(3, getOption(\"digits\") - 3),   signif.stars = getOption(\"show.signif.stars\"),   ... )  # S3 method for summary.ltmle print(x, ...)  # S3 method for ltmleEffectMeasures print(x, ...)  # S3 method for summary.ltmleEffectMeasures print(x, ...)  # S3 method for ltmleMSM print(x, ...)  # S3 method for ltmle print(x, ...)"},{"path":"http://joshuaschwab.github.io/ltmle/reference/summary.ltmle.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get standard error, p-value, and confidence interval for one ltmle object\nSummarizing results from Longitudinal Targeted Maximum Likelihood Estimation\n(ltmle) — summary.ltmle","text":"object object class \"ltmle\" \"ltmleMSM\" \"ltmleEffectMeasures\", usually result call ltmle ltmleMSM. estimator character; one \"tmle\", \"iptw\", \"gcomp\". estimator get effect measures. \"tmle\" valid iff original ltmle/ltmleMSM call used gcomp=FALSE. \"gcomp\" valid iff original ltmle/ltmleMSM call used gcomp=TRUE ... arguments passed methods. x object class \"summary.ltmle\" \"summary.ltmleMSM\" \"ltmleEffectMeasures\", usually result call summary.ltmle summary.ltmleMSM. digits number significant digits use printing. signif.stars logical. TRUE, significance stars printed coefficient.","code":""},{"path":"http://joshuaschwab.github.io/ltmle/reference/summary.ltmle.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get standard error, p-value, and confidence interval for one ltmle object\nSummarizing results from Longitudinal Targeted Maximum Likelihood Estimation\n(ltmle) — summary.ltmle","text":"summary.ltmle returns object class \"summary.ltmle\", list components treatment list components summarizing estimate object estimate - parameter estimate \\(E[Y_d]\\) std.dev - estimated standard deviation parameter p.value - two-sided p-value CI - vector length 2 95 percent confidence interval  call matched call ltmle object estimator estimator input argument variance.estimate.ratio ratio TMLE based variance estimate influence curve based variance estimate summary.ltmleEffectMeasures returns object class \"summary.ltmleEffectMeasures\", list components summary.ltmle , also includes: effect.measures list components, components treatment summary.ltmle treatment - corresponds first list abar (rule) passed ltmle control - corresponds second list abar (rule) passed ltmle ATE - average treatment effect RR - relative risk - odds ratio  summary.ltmleMSM returns object class \"summary.ltmleMSM\", matrix rows MSM parameter columns point estimate, standard error, 2.5percent confidence interval, 97.5percent confidence interval, p-value.","code":""},{"path":"http://joshuaschwab.github.io/ltmle/reference/summary.ltmle.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Get standard error, p-value, and confidence interval for one ltmle object\nSummarizing results from Longitudinal Targeted Maximum Likelihood Estimation\n(ltmle) — summary.ltmle","text":"summary.ltmle returns parameter value estimator, estimated variance, 95 percent confidence interval, p-value. summary.ltmleEffectMeasures returns additive treatment effect two objects abar list passed ltmle. Relative risk, odds ratio also returned, along variance, confidence interval, p-value . summary.ltmleMSM returns matrix MSM parameter estimates.","code":""},{"path":[]},{"path":"http://joshuaschwab.github.io/ltmle/reference/summary.ltmle.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Get standard error, p-value, and confidence interval for one ltmle object\nSummarizing results from Longitudinal Targeted Maximum Likelihood Estimation\n(ltmle) — summary.ltmle","text":"","code":"rexpit <- function(x) rbinom(n = length(x), size = 1, prob = plogis(x))  # Compare the expected outcomes under two counterfactual plans: Treatment plan: # set A1 to 1 if W > 0, set A2 to 1 if W > 1.5, always set A3 to 1 Control plan: # always set A1, A2, and A3 to 0 W <- rnorm(1000) A1 <- rexpit(W) A2 <- rexpit(W + 2 * A1) A3 <- rexpit(2 * A1 - A2) Y <- rexpit(W - A1 + 0.5 * A2 + 2 * A3) data <- data.frame(W, A1, A2, A3, Y) treatment <- cbind(W > 0, W > 1.5, 1) control <- matrix(0, nrow = 1000, ncol = 3) result <- ltmle(data, Anodes = c(\"A1\", \"A2\", \"A3\"), Ynodes = \"Y\", abar = list(treatment,     control)) #> Qform not specified, using defaults: #> formula for Y: #> Q.kplus1 ~ W + A1 + A2 + A3 #>  #> gform not specified, using defaults: #> formula for A1: #> A1 ~ W #> formula for A2: #> A2 ~ W + A1 #> formula for A3: #> A3 ~ W + A1 + A2 #>  #> Estimate of time to completion: < 1 minute print(summary(result)) #> Estimator:  tmle  #> Call: #> ltmle(data = data, Anodes = c(\"A1\", \"A2\", \"A3\"), Ynodes = \"Y\",  #>     abar = list(treatment, control)) #>  #> Treatment Estimate: #>    Parameter Estimate:  0.76323  #>     Estimated Std Err:  0.054433  #>               p-value:  <2e-16  #>     95% Conf Interval: (0.65654, 0.86991)  #>  #> Control Estimate: #>    Parameter Estimate:  0.46619  #>     Estimated Std Err:  0.064218  #>               p-value:  3.8871e-13  #>     95% Conf Interval: (0.34032, 0.59205)  #>  #> Additive Treatment Effect: #>    Parameter Estimate:  0.29704  #>     Estimated Std Err:  0.082759  #>               p-value:  0.00033163  #>     95% Conf Interval: (0.13484, 0.45925)  #>  #> Relative Risk: #>    Parameter Estimate:  1.6372  #>   Est Std Err log(RR):  0.15373  #>               p-value:  0.0013429  #>     95% Conf Interval: (1.2113, 2.2129)  #>  #> Odds Ratio: #>    Parameter Estimate:  3.6911  #>   Est Std Err log(OR):  0.38754  #>               p-value:  0.00075227  #>     95% Conf Interval: (1.727, 7.8891)  #>   ## For examples of summary.ltmle and summary.ltmleMSM, see example(ltmle)"}]
