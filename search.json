[{"path":"http://joshuaschwab.github.io/ltmle/articles/a01_overview.html","id":"ltmle","dir":"Articles","previous_headings":"","what":"ltmle()","title":"ltmle Package Overview","text":"data Anodes Ynodes abar Cnodes Lnodes SL.library survivalOutcome gbounds Yrange stratify SL.cvControl estimate.time gcomp iptw.variance.method observation.weights id Qform gform rule deterministic.g.function deterministic.Q.function","code":"ltmle(data, Anodes, Cnodes = NULL, Lnodes = NULL, Ynodes,   survivalOutcome = NULL, Qform = NULL, gform = NULL, abar,   rule = NULL, gbounds = c(0.01, 1), Yrange = NULL,   deterministic.g.function = NULL, stratify = FALSE,   SL.library = \"glm\", SL.cvControl = list(), estimate.time = TRUE,   gcomp = FALSE, iptw.only = FALSE, deterministic.Q.function = NULL,   variance.method = \"tmle\", observation.weights = NULL, id = NULL)"},{"path":"http://joshuaschwab.github.io/ltmle/articles/a01_overview.html","id":"ltmlemsm","dir":"Articles","previous_headings":"","what":"ltmleMSM()","title":"ltmle Package Overview","text":"data Anodes Ynodes regimes working.msm summary.measures Cnodes Lnodes SL.library survivalOutcome final.Ynodes msm.weights gbounds Yrange stratify SL.cvControl estimate.time gcomp iptw.variance.method observation.weights id Qform gform rule deterministic.g.function deterministic.Q.function","code":"ltmleMSM(data, Anodes, Cnodes = NULL, Lnodes = NULL, Ynodes,   survivalOutcome = NULL, Qform = NULL, gform = NULL,   gbounds = c(0.01, 1), Yrange = NULL,   deterministic.g.function = NULL, SL.library = \"glm\",   SL.cvControl = list(), regimes, working.msm, summary.measures,   final.Ynodes = NULL, stratify = FALSE, msm.weights = \"empirical\",   estimate.time = TRUE, gcomp = FALSE, iptw.only = FALSE,   deterministic.Q.function = NULL, variance.method = \"tmle\",   observation.weights = NULL, id = NULL)"},{"path":"http://joshuaschwab.github.io/ltmle/articles/a02_intro.html","id":"minimal-example","dir":"Articles","previous_headings":"","what":"Minimal Example","title":"Introduction to ltmle","text":"Consider observed data time ordering W -> -> Y. W continuous baseline covariate affects Y. binary treatment variable affects Y. Y binary outcome variable. W ~ N(0, 1) ~ binomial P(= 1) = expit(W) Y ~ binomial P(Y = 1) = expit(W + ) \\(expit(z) = \\frac{1}{1 + e^{-z}}\\) want know \\(E[Y_1]\\) expected value Y, intervening set 1. try use simple mean Y mean Y = 1, biased. Now use ltmle(). ’re using simulated data, can calculate true value \\(E[Y_1]\\)","code":"rexpit <- function(x) rbinom(n=length(x), size=1, prob=plogis(x)) n <- 10000 W <- rnorm(n) A <- rexpit(W) Y <- rexpit(W + A) data <- data.frame(W, A, Y) head(data) #>            W A Y #> 1  0.8134167 0 0 #> 2  0.3625437 0 1 #> 3  0.6247327 0 0 #> 4  0.7721537 0 0 #> 5  1.0331531 1 1 #> 6 -0.2282334 0 0 mean(Y) #> [1] 0.6025 mean(Y[A == 1]) #> [1] 0.7817085 result <- ltmle(data, Anodes = \"A\", Ynodes = \"Y\", abar = 1) #> Qform not specified, using defaults: #> formula for Y: #> Q.kplus1 ~ W + A #>  #> gform not specified, using defaults: #> formula for A: #> A ~ W #>  #> Estimate of time to completion: < 1 minute result #> Call: #> ltmle(data = data, Anodes = \"A\", Ynodes = \"Y\", abar = 1) #>  #> TMLE Estimate:  0.7053678 n.large <- 1e6 W <- rnorm(n.large) A <- 1 Y <- rexpit(W + A) mean(Y) #> [1] 0.697166"},{"path":"http://joshuaschwab.github.io/ltmle/articles/a02_intro.html","id":"single-time-point","dir":"Articles","previous_headings":"","what":"Single time point","title":"Introduction to ltmle","text":"Time ordering data W1 -> W2 -> W3 -> -> Y True value \\(E[Y_1]\\) approximately 0.5939. SuperLearner semiparametric estimation using parents regressors TMLE estimate: IPTW estimate: SuperLearner semiparametric estimation using correctly specified regressors. passes W1^2, W2, W3, W3:columns matrix X SuperLearner Q regression W1 W3 columns matrix X SuperLearner g regression. glm using correctly specified Qform gform Get summary measures (additive treatment effect, odds ratio, relative risk) abar=1 vs abar=0","code":"n <- 1000 W1 <- rnorm(n) W2 <- rbinom(n, size=1, prob=0.3)    W3 <- rnorm(n) A <- rexpit(-1 + 2 * W1 + W3) Y <- rexpit(-0.5 + 2 * W1^2 + 0.5 * W2 - 0.5 * A + 0.2 * W3 * A - 1.1 * W3) data <- data.frame(W1, W2, W3, A, Y) result <- ltmle(data, Anodes=\"A\", Lnodes=NULL, Ynodes=\"Y\", abar=1, SL.library=\"default\") #> Loading required namespace: SuperLearner #> Qform not specified, using defaults: #> formula for Y: #> Q.kplus1 ~ W1 + W2 + W3 + A #>  #> gform not specified, using defaults: #> formula for A: #> A ~ W1 + W2 + W3 #>  #> Loading required package: nnls #> Loading required namespace: arm #> Estimate of time to completion: 1 to 2 minutes summary(result) #> Estimator:  tmle  #> Call: #> ltmle(data = data, Anodes = \"A\", Lnodes = NULL, Ynodes = \"Y\",  #>     abar = 1, SL.library = \"default\") #>  #>    Parameter Estimate:  0.61313  #>     Estimated Std Err:  0.046501  #>               p-value:  <2e-16  #>     95% Conf Interval: (0.52199, 0.70427) summary(result, estimator=\"iptw\") #> Estimator:  iptw  #> Call: #> ltmle(data = data, Anodes = \"A\", Lnodes = NULL, Ynodes = \"Y\",  #>     abar = 1, SL.library = \"default\") #>  #>    Parameter Estimate:  0.59122  #>     Estimated Std Err:  0.030896  #>               p-value:  <2e-16  #>     95% Conf Interval: (0.53067, 0.65177) result <- ltmle(data, Anodes=\"A\", Lnodes=NULL, Ynodes=\"Y\",                  Qform=c(Y=\"Q.kplus1 ~ I(W1^2) + W2 + W3*A\"),                  gform=\"A ~ W1 + W3\", abar=1, SL.library=\"default\") #> Estimate of time to completion: 1 minute summary(result) #> Estimator:  tmle  #> Call: #> ltmle(data = data, Anodes = \"A\", Lnodes = NULL, Ynodes = \"Y\",  #>     Qform = c(Y = \"Q.kplus1 ~ I(W1^2) + W2 + W3*A\"), gform = \"A ~ W1 + W3\",  #>     abar = 1, SL.library = \"default\") #>  #>    Parameter Estimate:  0.6325  #>     Estimated Std Err:  0.034014  #>               p-value:  <2e-16  #>     95% Conf Interval: (0.56584, 0.69917) result <- ltmle(data, Anodes=\"A\", Lnodes=NULL, Ynodes=\"Y\",   Qform=c(Y=\"Q.kplus1 ~ I(W1^2) + W2 + W3*A\"), gform=\"A ~ W1 + W3\",   abar=1, SL.library=NULL) #> Estimate of time to completion: < 1 minute summary(result) #> Estimator:  tmle  #> Call: #> ltmle(data = data, Anodes = \"A\", Lnodes = NULL, Ynodes = \"Y\",  #>     Qform = c(Y = \"Q.kplus1 ~ I(W1^2) + W2 + W3*A\"), gform = \"A ~ W1 + W3\",  #>     abar = 1, SL.library = NULL) #>  #>    Parameter Estimate:  0.63239  #>     Estimated Std Err:  0.034267  #>               p-value:  <2e-16  #>     95% Conf Interval: (0.56523, 0.69955) result <- ltmle(data, Anodes=\"A\", Lnodes=NULL, Ynodes=\"Y\",                        abar=list(1, 0), SL.library=\"default\") #> Qform not specified, using defaults: #> formula for Y: #> Q.kplus1 ~ W1 + W2 + W3 + A #>  #> gform not specified, using defaults: #> formula for A: #> A ~ W1 + W2 + W3 #>  #> Estimate of time to completion: 1 minute summary(result) #> Estimator:  tmle  #> Call: #> ltmle(data = data, Anodes = \"A\", Lnodes = NULL, Ynodes = \"Y\",  #>     abar = list(1, 0), SL.library = \"default\") #>  #> Treatment Estimate: #>    Parameter Estimate:  0.61454  #>     Estimated Std Err:  0.045844  #>               p-value:  <2e-16  #>     95% Conf Interval: (0.52468, 0.70439)  #>  #> Control Estimate: #>    Parameter Estimate:  0.68544  #>     Estimated Std Err:  0.027963  #>               p-value:  <2e-16  #>     95% Conf Interval: (0.63063, 0.74024)  #>  #> Additive Treatment Effect: #>    Parameter Estimate:  -0.0709  #>     Estimated Std Err:  0.053699  #>               p-value:  0.18673  #>     95% Conf Interval: (-0.17615, 0.034349)  #>  #> Relative Risk: #>    Parameter Estimate:  0.89656  #>   Est Std Err log(RR):  0.085026  #>               p-value:  0.19908  #>     95% Conf Interval: (0.75894, 1.0591)  #>  #> Odds Ratio: #>    Parameter Estimate:  0.73165  #>   Est Std Err log(OR):  0.23297  #>               p-value:  0.17987  #>     95% Conf Interval: (0.46345, 1.1551)"},{"path":"http://joshuaschwab.github.io/ltmle/articles/a02_intro.html","id":"censoring","dir":"Articles","previous_headings":"","what":"Censoring","title":"Introduction to ltmle","text":"Time ordering data W -> C -> Y. C censoring node. parameter interest Y, intervening set C uncensored. Censoring nodes similar treatment nodes. main difference censoring, data expected NA. assumed parameter interest always intervenes set censoring nodes uncensored, specified abar. g Q regressions always stratify censoring nodes, whereas g Q regressions can either stratify pool treatment nodes (using stratify argument.) Censoring nodes data factors two levels - “censored” “uncensored”. utility function BinaryToCensoring can used facilitate . naive estimate biased (true value 0.5):","code":"n <- 100000 W <- rnorm(n) C <- BinaryToCensoring(is.censored = rexpit(W)) summary(C) #>   censored uncensored  #>      49962      50038 Y <- rep(NA, n) Y[C == \"uncensored\"] <- rexpit(W[C == \"uncensored\"]) data <- data.frame(W, C, Y) head(data, 20) #>               W          C  Y #> 1  -0.401247694   censored NA #> 2   0.344375907   censored NA #> 3  -0.978055713 uncensored  0 #> 4  -0.576122056   censored NA #> 5   1.168682578   censored NA #> 6   1.763147572   censored NA #> 7   1.450346820 uncensored  0 #> 8  -1.316843540 uncensored  0 #> 9  -0.003540234 uncensored  1 #> 10  0.179439924 uncensored  1 #> 11  0.986671190   censored NA #> 12 -0.008727362 uncensored  1 #> 13  0.752074021   censored NA #> 14  1.092588147   censored NA #> 15  0.617482345 uncensored  1 #> 16 -0.682897811   censored NA #> 17 -0.521943520   censored NA #> 18  0.684433187 uncensored  1 #> 19  1.147623622   censored NA #> 20  2.480473765   censored NA result <- ltmle(data, Anodes = NULL, Cnodes = \"C\", Ynodes = \"Y\", abar = NULL) #> Qform not specified, using defaults: #> formula for Y: #> Q.kplus1 ~ W #>  #> gform not specified, using defaults: #> formula for C: #> C ~ W #>  #> Estimate of time to completion: 1 minute summary(result) #> Estimator:  tmle  #> Call: #> ltmle(data = data, Anodes = NULL, Cnodes = \"C\", Ynodes = \"Y\",  #>     abar = NULL) #>  #>    Parameter Estimate:  0.49902  #>     Estimated Std Err:  0.0023399  #>               p-value:  <2e-16  #>     95% Conf Interval: (0.49443, 0.5036) mean(data$Y) #> [1] NA mean(data$Y, na.rm = T) #> [1] 0.413206"},{"path":"http://joshuaschwab.github.io/ltmle/articles/a02_intro.html","id":"longitudinal-data","dir":"Articles","previous_headings":"","what":"Longitudinal data","title":"Introduction to ltmle","text":"Time ordering data W -> A1 -> L -> A2 -> Y. L time-dependent covariate occurs treatment (censoring) variable, A1. indicate using Lnodes argument. Treatment regime interest: set A1 0, set A2 0","code":"n <- 1000 W <- rnorm(n) A1 <- rexpit(W) L <- 0.3 * W + 0.2 * A1 + rnorm(n) A2 <- rexpit(W + A1 + L) Y <- rexpit(W - 0.6 * A1 + L - 0.8 * A2) data <- data.frame(W, A1, L, A2, Y) head(data) #>             W A1          L A2 Y #> 1 -0.45873170  0  2.3830277  1 1 #> 2  1.39178381  0  1.2826659  1 1 #> 3 -1.56179608  0  0.1775910  1 0 #> 4  0.01141841  0 -1.3279717  0 0 #> 5  1.60053701  1 -1.3782538  1 0 #> 6  0.86174793  1 -0.2082456  0 0 ltmle(data, Anodes=c(\"A1\", \"A2\"), Lnodes=\"L\", Ynodes=\"Y\", abar=c(0, 0)) #> Qform not specified, using defaults: #> formula for L: #> Q.kplus1 ~ W + A1 #> formula for Y: #> Q.kplus1 ~ W + A1 + L + A2 #>  #> gform not specified, using defaults: #> formula for A1: #> A1 ~ W #> formula for A2: #> A2 ~ W + A1 + L #>  #> Estimate of time to completion: < 1 minute #> Call: #> ltmle(data = data, Anodes = c(\"A1\", \"A2\"), Lnodes = \"L\", Ynodes = \"Y\",  #>     abar = c(0, 0)) #>  #> TMLE Estimate:  0.4822286"},{"path":"http://joshuaschwab.github.io/ltmle/articles/a02_intro.html","id":"longitudinal-data-with-censoring","dir":"Articles","previous_headings":"","what":"Longitudinal data with censoring","title":"Introduction to ltmle","text":"W -> A1 -> C -> L -> A2 -> Y Treatment regime interest: set A1 1, set A2 0, set C uncensored:","code":"n <- 1000 W <- rnorm(n) A1 <- rexpit(W) C <- BinaryToCensoring(is.censored = rexpit(0.6 * W - 0.5 * A1)) uncensored <- C == \"uncensored\" L <- A2 <- Y <- rep(NA, n) L[uncensored] <- (0.3 * W[uncensored] + 0.2 * A1[uncensored] + rnorm(sum(uncensored))) A2[uncensored] <- rexpit(W[uncensored] + A1[uncensored] + L[uncensored]) Y[uncensored] <- rexpit(W[uncensored] - 0.6 * A1[uncensored] + L[uncensored] - 0.8 * A2[uncensored]) data <- data.frame(W, A1, C, L, A2, Y) head(data) #>            W A1          C          L A2  Y #> 1 -0.4360245  0 uncensored -0.8278242  0  0 #> 2  1.5851055  1 uncensored  2.0021827  1  1 #> 3 -0.5251617  0   censored         NA NA NA #> 4 -0.1236538  0   censored         NA NA NA #> 5  2.3310144  1   censored         NA NA NA #> 6  0.2353337  0   censored         NA NA NA ltmle(data, Anodes=c(\"A1\", \"A2\"), Cnodes = \"C\", Lnodes=\"L\", Ynodes=\"Y\", abar=c(1, 0)) #> Qform not specified, using defaults: #> formula for L: #> Q.kplus1 ~ W + A1 #> formula for Y: #> Q.kplus1 ~ W + A1 + L + A2 #>  #> gform not specified, using defaults: #> formula for A1: #> A1 ~ W #> formula for C: #> C ~ W + A1 #> formula for A2: #> A2 ~ W + A1 + L #>  #> Estimate of time to completion: < 1 minute #> Call: #> ltmle(data = data, Anodes = c(\"A1\", \"A2\"), Cnodes = \"C\", Lnodes = \"L\",  #>     Ynodes = \"Y\", abar = c(1, 0)) #>  #> TMLE Estimate:  0.5321709"},{"path":"http://joshuaschwab.github.io/ltmle/articles/a02_intro.html","id":"dynamic-treatment","dir":"Articles","previous_headings":"","what":"Dynamic treatment","title":"Introduction to ltmle","text":"Treatment regime interest : Always treat time 1 (A1 = 1), treat time 2 (A2 = 1) L > 0 regime can also specified rule function. rule function applied row data returns numeric vector length Anodes. Specfifying regime using abar using rule give result:","code":"abar <- matrix(nrow=n, ncol=2) abar[, 1] <- 1 abar[, 2] <- L > 0  result.abar <- ltmle(data, Anodes=c(\"A1\", \"A2\"), Cnodes = \"C\", Lnodes=\"L\", Ynodes=\"Y\", abar=abar) #> Qform not specified, using defaults: #> formula for L: #> Q.kplus1 ~ W + A1 #> formula for Y: #> Q.kplus1 ~ W + A1 + L + A2 #>  #> gform not specified, using defaults: #> formula for A1: #> A1 ~ W #> formula for C: #> C ~ W + A1 #> formula for A2: #> A2 ~ W + A1 + L #>  #> Estimate of time to completion: < 1 minute result.abar #> Call: #> ltmle(data = data, Anodes = c(\"A1\", \"A2\"), Cnodes = \"C\", Lnodes = \"L\",  #>     Ynodes = \"Y\", abar = abar) #>  #> TMLE Estimate:  0.3047568 rule <- function(row) c(1, row[\"L\"] > 0)  result.rule <- ltmle(data, Anodes=c(\"A1\", \"A2\"), Cnodes = \"C\", Lnodes=\"L\", Ynodes=\"Y\", rule=rule) #> Qform not specified, using defaults: #> formula for L: #> Q.kplus1 ~ W + A1 #> formula for Y: #> Q.kplus1 ~ W + A1 + L + A2 #>  #> gform not specified, using defaults: #> formula for A1: #> A1 ~ W #> formula for C: #> C ~ W + A1 #> formula for A2: #> A2 ~ W + A1 + L #>  #> Estimate of time to completion: < 1 minute result.rule #> Call: #> ltmle(data = data, Anodes = c(\"A1\", \"A2\"), Cnodes = \"C\", Lnodes = \"L\",  #>     Ynodes = \"Y\", rule = rule) #>  #> TMLE Estimate:  0.3047568 summary(result.abar) #> Estimator:  tmle  #> Call: #> ltmle(data = data, Anodes = c(\"A1\", \"A2\"), Cnodes = \"C\", Lnodes = \"L\",  #>     Ynodes = \"Y\", abar = abar) #>  #>    Parameter Estimate:  0.30476  #>     Estimated Std Err:  0.032637  #>               p-value:  <2e-16  #>     95% Conf Interval: (0.24079, 0.36872) summary(result.rule) #> Estimator:  tmle  #> Call: #> ltmle(data = data, Anodes = c(\"A1\", \"A2\"), Cnodes = \"C\", Lnodes = \"L\",  #>     Ynodes = \"Y\", rule = rule) #>  #>    Parameter Estimate:  0.30476  #>     Estimated Std Err:  0.032637  #>               p-value:  <2e-16  #>     95% Conf Interval: (0.24079, 0.36872)"},{"path":"http://joshuaschwab.github.io/ltmle/articles/a02_intro.html","id":"variance-estimation","dir":"Articles","previous_headings":"","what":"Variance estimation","title":"Introduction to ltmle","text":"Consider simple point treatment problem observed data \\(W, , Y\\). positivity problem - small values \\(W\\), \\(Prob(= 1)\\) small. true parameter value, \\(E[Y_1]\\) approximately 0.697. true TMLE standard deviation (standard deviation TMLE estimate ran many times many sets data) approximately 0.056. true IPTW standard deviation (standard deviation IPTW estimate ran many times many sets data) approximately 0.059. default variance.method \"tmle\" - use TMLE order approximate variance TMLE estimator. estimated standard deviation close true TMLE standard deviation. variance.method \"ic\", variance estimated using estimated Influence Curve. fast compute, may significantly anticonservative data positivity violations. variance.method \"iptw\", use IPTW order approximate variance TMLE estimator. faster compute variance.method = \"tmle\" less accurate (slower compute variance.method = \"ic\" accurate). use IPTW estimator, variance.method change estimated standard deviation (affects estimated standard deviation TMLE estimator). can see values g small.","code":"n <- 1000 W <- rnorm(n) A <- rexpit(4 * W) Y <- rexpit(W + A) df <- data.frame(W, A, Y) r1 <- ltmle(df, Anodes=\"A\", Ynodes=\"Y\", abar = 1, estimate.time=FALSE) #> Qform not specified, using defaults: #> formula for Y: #> Q.kplus1 ~ W + A #>  #> gform not specified, using defaults: #> formula for A: #> A ~ W #>  print(summary(r1)) #> Estimator:  tmle  #> Call: #> ltmle(data = df, Anodes = \"A\", Ynodes = \"Y\", abar = 1, estimate.time = FALSE) #>  #>    Parameter Estimate:  0.66969  #>     Estimated Std Err:  0.060703  #>               p-value:  <2e-16  #>     95% Conf Interval: (0.55071, 0.78866) r2 <- ltmle(df, Anodes=\"A\", Ynodes=\"Y\", abar = 1, estimate.time=FALSE,   variance.method=\"ic\") #> Qform not specified, using defaults: #> formula for Y: #> Q.kplus1 ~ W + A #>  #> gform not specified, using defaults: #> formula for A: #> A ~ W #>  #> Warning in CheckForVarianceWarning(inputs, g.ratio): Variance estimate is based #> on influence curve only, which may be significantly anticonservative because #> your data appears to contain positivity violations. It is recommended to use #> variance.method='tmle' or variance.method='iptw' to obtain a more robust #> variance estimate (but run time may be significantly longer). See #> variance.method details in ?ltmle print(summary(r2)) #> Estimator:  tmle  #> Call: #> ltmle(data = df, Anodes = \"A\", Ynodes = \"Y\", abar = 1, estimate.time = FALSE,  #>     variance.method = \"ic\") #>  #>    Parameter Estimate:  0.66969  #>     Estimated Std Err:  0.04401  #>               p-value:  <2e-16  #>     95% Conf Interval: (0.58343, 0.75595) r3 <- ltmle(df, Anodes=\"A\", Ynodes=\"Y\", abar = 1, estimate.time=FALSE,   variance.method=\"iptw\") #> Qform not specified, using defaults: #> formula for Y: #> Q.kplus1 ~ W + A #>  #> gform not specified, using defaults: #> formula for A: #> A ~ W #>  print(summary(r3)) #> Estimator:  tmle  #> Call: #> ltmle(data = df, Anodes = \"A\", Ynodes = \"Y\", abar = 1, estimate.time = FALSE,  #>     variance.method = \"iptw\") #>  #>    Parameter Estimate:  0.66969  #>     Estimated Std Err:  0.053186  #>               p-value:  <2e-16  #>     95% Conf Interval: (0.56545, 0.77393) print(summary(r1, estimator=\"iptw\")) #> Estimator:  iptw  #> Call: #> ltmle(data = df, Anodes = \"A\", Ynodes = \"Y\", abar = 1, estimate.time = FALSE) #>  #>    Parameter Estimate:  0.72006  #>     Estimated Std Err:  0.052111  #>               p-value:  <2e-16  #>     95% Conf Interval: (0.61793, 0.8222) print(summary(r2, estimator=\"iptw\")) #the same - variance.method only affects TMLE #> Estimator:  iptw  #> Call: #> ltmle(data = df, Anodes = \"A\", Ynodes = \"Y\", abar = 1, estimate.time = FALSE,  #>     variance.method = \"ic\") #>  #>    Parameter Estimate:  0.72006  #>     Estimated Std Err:  0.052111  #>               p-value:  <2e-16  #>     95% Conf Interval: (0.61793, 0.8222) print(summary(r3, estimator=\"iptw\")) #the same - variance.method only affects TMLE #> Estimator:  iptw  #> Call: #> ltmle(data = df, Anodes = \"A\", Ynodes = \"Y\", abar = 1, estimate.time = FALSE,  #>     variance.method = \"iptw\") #>  #>    Parameter Estimate:  0.72006  #>     Estimated Std Err:  0.052111  #>               p-value:  <2e-16  #>     95% Conf Interval: (0.61793, 0.8222) summary(r1$cum.g) #>        V1          #>  Min.   :0.01000   #>  1st Qu.:0.04636   #>  Median :0.43801   #>  Mean   :0.48204   #>  3rd Qu.:0.92743   #>  Max.   :1.00000 summary(r1$cum.g.unbounded) #>        V1            #>  Min.   :0.0000034   #>  1st Qu.:0.0463619   #>  Median :0.4380090   #>  Mean   :0.4810000   #>  3rd Qu.:0.9274284   #>  Max.   :0.9999998 head(data.frame(df, g = r1$cum.g, g.unbounded = r1$cum.g.unbounded), 20) #>               W A Y          g  g.unbounded #> 1  -2.547528148 0 0 0.01000000 0.0000206524 #> 2   0.395693963 0 1 0.83572583 0.8357258294 #> 3   0.298522443 1 1 0.77151706 0.7715170640 #> 4   1.454576165 1 1 0.99774669 0.9977466850 #> 5  -0.238234778 0 0 0.25977689 0.2597768895 #> 6   1.079518202 1 1 0.98913317 0.9891331684 #> 7  -0.394463416 0 1 0.15367075 0.1536707455 #> 8  -0.243298336 1 1 0.25569103 0.2556910295 #> 9  -1.017860034 0 0 0.01292523 0.0129252336 #> 10 -0.910709808 0 0 0.02016160 0.0201615996 #> 11 -1.596117871 0 1 0.01000000 0.0011410800 #> 12 -1.764476874 0 0 0.01000000 0.0005612562 #> 13 -0.101793931 0 0 0.38423167 0.3842316710 #> 14  0.444689487 1 1 0.86216929 0.8621692886 #> 15  0.009522572 1 0 0.49947613 0.4994761318 #> 16 -0.394283503 0 0 0.15376947 0.1537694669 #> 17  0.295258520 1 1 0.76908115 0.7690811481 #> 18 -0.539534761 0 1 0.08964292 0.0896429169 #> 19 -1.453828629 0 0 0.01000000 0.0020775906 #> 20  0.796213361 1 1 0.96497846 0.9649784618"},{"path":"http://joshuaschwab.github.io/ltmle/articles/a02_intro.html","id":"hierarchical-data-and-the-id-variable","dir":"Articles","previous_headings":"","what":"Hierarchical data and the id variable","title":"Introduction to ltmle","text":"id argument can used specify hierarchical data, people household. id can integer, factor, character (type can coerced factor), Omitting id argument makes individuals seem independent , gives artificially low variance estimates. influence curve vector length equal number independent units.","code":"num.households <- 500 people.in.household <- round(runif(num.households, min = 1, max = 10)) length(people.in.household) #> [1] 500 n <- sum(people.in.household)  n #> [1] 2779 W.household <- rnorm(num.households) length(W.household) #> [1] 500 W.household.expanded <- rep(W.household, times = people.in.household) W.indiv <- rnorm(n) length(W.indiv) #> [1] 2779 A <- rexpit(1.5 * W.household.expanded + 0.4 * W.indiv) Y <- rexpit(-1 + 2.3 * W.household.expanded - 0.6 * W.indiv + 1.2 * A) id <- 1:num.households  id.expanded <- rep(id, times = people.in.household) data <- data.frame(W.household.expanded, W.indiv, A, Y) head(cbind(id.expanded, data), 20) #>    id.expanded W.household.expanded     W.indiv A Y #> 1            1            0.7338290  0.19167419 1 1 #> 2            1            0.7338290 -0.27671546 1 1 #> 3            2            0.2383485  0.42544393 0 0 #> 4            2            0.2383485  0.20770280 0 0 #> 5            2            0.2383485 -0.70788107 1 1 #> 6            2            0.2383485  0.16072397 1 1 #> 7            2            0.2383485  0.76005943 1 0 #> 8            2            0.2383485  0.06808388 1 1 #> 9            2            0.2383485  0.96140078 0 0 #> 10           2            0.2383485  0.20371661 0 0 #> 11           2            0.2383485 -0.66029422 1 1 #> 12           2            0.2383485  0.86632469 0 0 #> 13           3           -1.3096128 -0.27916221 0 0 #> 14           3           -1.3096128 -0.61063012 1 0 #> 15           3           -1.3096128  1.22858659 0 0 #> 16           4           -0.4621275  1.29635135 0 0 #> 17           4           -0.4621275 -0.23697455 0 0 #> 18           5            1.0955654 -0.68682486 1 1 #> 19           5            1.0955654 -0.56653722 0 1 #> 20           5            1.0955654  0.38059233 0 1 result.without.id <- ltmle(data, Anodes = \"A\", Ynodes = \"Y\", abar = 0) #> Qform not specified, using defaults: #> formula for Y: #> Q.kplus1 ~ W.household.expanded + W.indiv + A #>  #> gform not specified, using defaults: #> formula for A: #> A ~ W.household.expanded + W.indiv #>  #> Estimate of time to completion: < 1 minute result.with.id <- ltmle(data, Anodes = \"A\", Ynodes = \"Y\", abar = 0, id = id.expanded) #> Qform not specified, using defaults: #> formula for Y: #> Q.kplus1 ~ W.household.expanded + W.indiv + A #>  #> gform not specified, using defaults: #> formula for A: #> A ~ W.household.expanded + W.indiv #>  #> Estimate of time to completion: < 1 minute summary(result.without.id) #> Estimator:  tmle  #> Call: #> ltmle(data = data, Anodes = \"A\", Ynodes = \"Y\", abar = 0) #>  #>    Parameter Estimate:  0.35783  #>     Estimated Std Err:  0.013589  #>               p-value:  <2e-16  #>     95% Conf Interval: (0.33119, 0.38446) summary(result.with.id) #> Estimator:  tmle  #> Call: #> ltmle(data = data, Anodes = \"A\", Ynodes = \"Y\", abar = 0, id = id.expanded) #>  #>    Parameter Estimate:  0.35783  #>     Estimated Std Err:  0.021422  #>               p-value:  <2e-16  #>     95% Conf Interval: (0.31584, 0.39981) length(result.without.id$IC$tmle) #> [1] 2779 length(result.with.id$IC$tmle) #> [1] 500"},{"path":"http://joshuaschwab.github.io/ltmle/articles/a02_intro.html","id":"multiple-time-dependent-covariates-and-treatments-at-each-time-point-continuous-y-values","dir":"Articles","previous_headings":"","what":"Multiple time-dependent covariates and treatments at each time point, continuous Y values","title":"Introduction to ltmle","text":"age -> gender -> A1 -> L1a -> L1b -> Y1 -> A2 -> L2a -> L2b -> Y2 Also show different ways specifying nodes (either names indexes works):","code":"n <- 1000 age <- rbinom(n, 1, 0.5) gender <- rbinom(n, 1, 0.5) A1 <- rexpit(age + gender) L1a <- 2*age - 3*gender + 2*A1 + rnorm(n) L1b <- rexpit(age + 1.5*gender - A1) Y1 <- plogis(age - gender + L1a + 0.7*L1b + A1 + rnorm(n)) A2 <- rexpit(age + gender + A1 - L1a - L1b) L2a <- 2*age - 3*gender + 2*A1 + A2 + rnorm(n) L2b <- rexpit(age + 1.5*gender - A1 - A2) Y2 <- plogis(age - gender + L1a + L1b + A1 + 1.8*A2 + rnorm(n)) data <- data.frame(age, gender, A1, L1a, L1b, Y1, A2, L2a, L2b, Y2) result <- ltmle(data, Anodes=c(3, 7), Lnodes=c(\"L1a\", \"L1b\", \"L2a\", \"L2b\"),   Ynodes=grep(\"^Y\", names(data)), abar=c(1, 0))  #> Qform not specified, using defaults: #> formula for L1a: #> Q.kplus1 ~ age + gender + A1 #> formula for L2a: #> Q.kplus1 ~ age + gender + A1 + L1a + L1b + Y1 + A2 #>  #> gform not specified, using defaults: #> formula for A1: #> A1 ~ age + gender #> formula for A2: #> A2 ~ age + gender + A1 + L1a + L1b + Y1 #>  #> Estimate of time to completion: < 1 minute #> Warning in CheckForVarianceWarning(inputs, g.ratio): Variance estimate is based #> on influence curve only, which may be significantly anticonservative because #> your data appears to contain positivity violations. Robust variance estimate is #> not currently available with non binary outcomes but this will be addressed in #> a future release. summary(result) #> Estimator:  tmle  #> Call: #> ltmle(data = data, Anodes = c(3, 7), Lnodes = c(\"L1a\", \"L1b\",  #>     \"L2a\", \"L2b\"), Ynodes = grep(\"^Y\", names(data)), abar = c(1,  #>     0)) #>  #>    Parameter Estimate:  0.80031  #>     Estimated Std Err:  0.018014  #>               p-value:  <2e-16  #>     95% Conf Interval: (0.765, 0.83561)"},{"path":"http://joshuaschwab.github.io/ltmle/articles/a02_intro.html","id":"specifying-qform","dir":"Articles","previous_headings":"","what":"Specifying Qform","title":"Introduction to ltmle","text":"Usually specify Qform Lnodes Ynodes case L1a, L1b, Y1 “block” L/Y nodes separated Anodes Cnodes (true L2a, L2b, Y2). one regression required first L/Y node block. can pass regression formulas L/Y nodes, ignored. Gives result prints message saying regression formulas dropped: Anode Cnode L1b Y1, Y1 also need Q regression formula.","code":"result <- ltmle(data, Anodes=c(3, 7), Lnodes=c(\"L1a\", \"L1b\", \"L2a\", \"L2b\"),   Ynodes=grep(\"^Y\", names(data)), abar=c(1, 0),   Qform=c(L1a=\"Q.kplus1 ~ 1\", L2a=\"Q.kplus1 ~ 1\")) #> gform not specified, using defaults: #> formula for A1: #> A1 ~ age + gender #> formula for A2: #> A2 ~ age + gender + A1 + L1a + L1b + Y1 #>  #> Estimate of time to completion: < 1 minute #> Warning in CheckForVarianceWarning(inputs, g.ratio): Variance estimate is based #> on influence curve only, which may be significantly anticonservative because #> your data appears to contain positivity violations. Robust variance estimate is #> not currently available with non binary outcomes but this will be addressed in #> a future release. summary(result) #> Estimator:  tmle  #> Call: #> ltmle(data = data, Anodes = c(3, 7), Lnodes = c(\"L1a\", \"L1b\",  #>     \"L2a\", \"L2b\"), Ynodes = grep(\"^Y\", names(data)), Qform = c(L1a = \"Q.kplus1 ~ 1\",  #>     L2a = \"Q.kplus1 ~ 1\"), abar = c(1, 0)) #>  #>    Parameter Estimate:  0.82764  #>     Estimated Std Err:  0.03305  #>               p-value:  <2e-16  #>     95% Conf Interval: (0.76286, 0.89242) result <- ltmle(data, Anodes=c(3, 7), Lnodes=c(\"L1a\", \"L1b\", \"L2a\", \"L2b\"),   Ynodes=grep(\"^Y\", names(data)), abar=c(1, 0),   Qform=c(L1a=\"Q.kplus1 ~ 1\", L1b=\"Q.klus1~A1\",   Y1=\"Q.kplus1~L1a\", L2a=\"Q.kplus1 ~ 1\", L2b=\"Q.klus1~A1\", Y2=\"Q.kplus1~A2 + gender\")) #> L/Y nodes (after removing blocks)  : L1a L2a #> Qform names                        : L1a L1b Y1 L2a L2b Y2 #> The following nodes are not being considered as L/Y nodes because they are part of a block #> of L/Y nodes. They are being dropped from Qform: #> L1b  #>  Y1  #>  L2b  #>  Y2 #> gform not specified, using defaults: #> formula for A1: #> A1 ~ age + gender #> formula for A2: #> A2 ~ age + gender + A1 + L1a + L1b + Y1 #>  #> Estimate of time to completion: < 1 minute #> Warning in CheckForVarianceWarning(inputs, g.ratio): Variance estimate is based #> on influence curve only, which may be significantly anticonservative because #> your data appears to contain positivity violations. Robust variance estimate is #> not currently available with non binary outcomes but this will be addressed in #> a future release. summary(result) #> Estimator:  tmle  #> Call: #> ltmle(data = data, Anodes = c(3, 7), Lnodes = c(\"L1a\", \"L1b\",  #>     \"L2a\", \"L2b\"), Ynodes = grep(\"^Y\", names(data)), Qform = c(L1a = \"Q.kplus1 ~ 1\",  #>     L1b = \"Q.klus1~A1\", Y1 = \"Q.kplus1~L1a\", L2a = \"Q.kplus1 ~ 1\",  #>     L2b = \"Q.klus1~A1\", Y2 = \"Q.kplus1~A2 + gender\"), abar = c(1,  #>     0)) #>  #>    Parameter Estimate:  0.82764  #>     Estimated Std Err:  0.03305  #>               p-value:  <2e-16  #>     95% Conf Interval: (0.76286, 0.89242)"},{"path":"http://joshuaschwab.github.io/ltmle/articles/a03_msm.html","id":"marginal-structural-models-msms---multiple-regimes-with-a-single-outcome","dir":"Articles","previous_headings":"","what":"Marginal Structural Models (MSMs) - Multiple regimes with a single outcome","title":"Marginal Structural Models - ltmleMSM","text":"example 5 time points treatment time varying covariate. , treatment can 0 1. single outcome Y. L_0 L_1 A_1 L_2 A_2 … L_5 A_5 Y 2^5 = 32 regimes interest. may limited support patients follow particular regime. pool regimes using working marginal structural model. example want know effect time treatment Y. include time..treatment time..treatment^2. large numbers regimes, variance.method = \"ic\" much faster, may give anticonservative confidence intervals. may want use variance.method = \"ic\" first make sure MSM coefficients look reasonable use variance.method = \"tmle\" (default) final estimates. Suppose interested effect time treatment Y considering regimes include least 3 periods treatment.","code":"rexpit <- function(x) rbinom(n=length(x), size=1, prob=plogis(x)) n <- 5000 time.points <- 5 prev.L <- rnorm(n) prev.A <- rep(0, n) sum.A <- rep(0, n) data <- data.frame(L_0 = prev.L) for (t in 1:time.points) {   L <- 0.1 * prev.L + 0.3 * prev.A + rnorm(n)   A <- rexpit(L)      data1 <- data.frame(L, A)   names(data1) <- paste0(c(\"L_\", \"A_\"), t)   data <- cbind(data, data1)      prev.A <- A   prev.L <- L      sum.A <- sum.A + A } data$Y <- rexpit(sum.A / time.points + L) head(data) #>          L_0        L_1 A_1        L_2 A_2        L_3 A_3         L_4 A_4 #> 1  0.7684782  0.9018507   1 -0.3134310   0  0.1254824   0  0.67711492   1 #> 2  0.2873745  1.2424103   1 -0.2840722   0  0.8816280   0  0.31577302   1 #> 3 -0.4204289 -0.3859440   0 -0.9147901   1 -0.8346919   0 -0.21866690   0 #> 4  0.1862478  0.3362542   1 -0.1418278   0 -0.3323630   0 -2.12948867   0 #> 5  1.8053980 -1.6832237   0 -1.4325142   1  0.5542218   1  0.92426054   1 #> 6 -1.6147542  0.3036425   1  0.7852432   0 -0.5584219   0  0.09008135   1 #>          L_5 A_5 Y #> 1 -0.6059644   0 0 #> 2  0.2887320   1 0 #> 3 -0.1352839   1 1 #> 4  0.8750801   0 0 #> 5  1.1145555   1 0 #> 6 -0.2656053   0 0 regime.matrix <- as.matrix(expand.grid(rep(list(0:1), time.points))) dim(regime.matrix) #> [1] 32  5 head(regime.matrix, 20) #>       Var1 Var2 Var3 Var4 Var5 #>  [1,]    0    0    0    0    0 #>  [2,]    1    0    0    0    0 #>  [3,]    0    1    0    0    0 #>  [4,]    1    1    0    0    0 #>  [5,]    0    0    1    0    0 #>  [6,]    1    0    1    0    0 #>  [7,]    0    1    1    0    0 #>  [8,]    1    1    1    0    0 #>  [9,]    0    0    0    1    0 #> [10,]    1    0    0    1    0 #> [11,]    0    1    0    1    0 #> [12,]    1    1    0    1    0 #> [13,]    0    0    1    1    0 #> [14,]    1    0    1    1    0 #> [15,]    0    1    1    1    0 #> [16,]    1    1    1    1    0 #> [17,]    0    0    0    0    1 #> [18,]    1    0    0    0    1 #> [19,]    0    1    0    0    1 #> [20,]    1    1    0    0    1 num.regimes <- 2^time.points regimes <- array(dim = c(n, time.points, num.regimes)) #n x numAnodes x numRegimes = n x time.points x 2^time.points summary.measures <- array(dim = c(num.regimes, 1, 1)) #numRegimes x num.summary.measures x num.final.Ynodes = 2^time.points x 1 x 1 for (i in 1:num.regimes) {   regimes[, , i] <- matrix(regime.matrix[i, ], byrow = TRUE, nrow = n, ncol = time.points)   summary.measures[i, 1, 1] <- sum(regime.matrix[i, ]) } colnames(summary.measures) <- \"time.on.treatment\" regimes[1:3, , 1:3] #> , , 1 #>  #>      [,1] [,2] [,3] [,4] [,5] #> [1,]    0    0    0    0    0 #> [2,]    0    0    0    0    0 #> [3,]    0    0    0    0    0 #>  #> , , 2 #>  #>      [,1] [,2] [,3] [,4] [,5] #> [1,]    1    0    0    0    0 #> [2,]    1    0    0    0    0 #> [3,]    1    0    0    0    0 #>  #> , , 3 #>  #>      [,1] [,2] [,3] [,4] [,5] #> [1,]    0    1    0    0    0 #> [2,]    0    1    0    0    0 #> [3,]    0    1    0    0    0 summary.measures #> , , 1 #>  #>       time.on.treatment #>  [1,]                 0 #>  [2,]                 1 #>  [3,]                 1 #>  [4,]                 2 #>  [5,]                 1 #>  [6,]                 2 #>  [7,]                 2 #>  [8,]                 3 #>  [9,]                 1 #> [10,]                 2 #> [11,]                 2 #> [12,]                 3 #> [13,]                 2 #> [14,]                 3 #> [15,]                 3 #> [16,]                 4 #> [17,]                 1 #> [18,]                 2 #> [19,]                 2 #> [20,]                 3 #> [21,]                 2 #> [22,]                 3 #> [23,]                 3 #> [24,]                 4 #> [25,]                 2 #> [26,]                 3 #> [27,]                 3 #> [28,]                 4 #> [29,]                 3 #> [30,]                 4 #> [31,]                 4 #> [32,]                 5 result1 <- ltmleMSM(data, Anodes = paste0(\"A_\", 1:time.points),                      Lnodes = paste0(\"L_\", 0:time.points), Ynodes = \"Y\",                      regimes = regimes, summary.measures = summary.measures,                      working.msm = \"Y ~ time.on.treatment + I(time.on.treatment^2)\",                     variance.method = \"ic\") #> Qform not specified, using defaults: #> formula for L_2: #> Q.kplus1 ~ L_0 + L_1 + A_1 #> formula for L_3: #> Q.kplus1 ~ L_0 + L_1 + A_1 + L_2 + A_2 #> formula for L_4: #> Q.kplus1 ~ L_0 + L_1 + A_1 + L_2 + A_2 + L_3 + A_3 #> formula for L_5: #> Q.kplus1 ~ L_0 + L_1 + A_1 + L_2 + A_2 + L_3 + A_3 + L_4 + A_4 #> formula for Y: #> Q.kplus1 ~ L_0 + L_1 + A_1 + L_2 + A_2 + L_3 + A_3 + L_4 + A_4 +     L_5 + A_5 #>  #> gform not specified, using defaults: #> formula for A_1: #> A_1 ~ L_0 + L_1 #> formula for A_2: #> A_2 ~ L_0 + L_1 + A_1 + L_2 #> formula for A_3: #> A_3 ~ L_0 + L_1 + A_1 + L_2 + A_2 + L_3 #> formula for A_4: #> A_4 ~ L_0 + L_1 + A_1 + L_2 + A_2 + L_3 + A_3 + L_4 #> formula for A_5: #> A_5 ~ L_0 + L_1 + A_1 + L_2 + A_2 + L_3 + A_3 + L_4 + A_4 + L_5 #>  #> Estimate of time to completion: 1 minute #> Warning in CheckForVarianceWarning(inputs, g.ratio): Variance estimate is based #> on influence curve only, which may be significantly anticonservative because #> your data appears to contain positivity violations. It is recommended to use #> variance.method='tmle' or variance.method='iptw' to obtain a more robust #> variance estimate (but run time may be significantly longer). See #> variance.method details in ?ltmle result2 <- ltmleMSM(data, Anodes = paste0(\"A_\", 1:time.points),                      Lnodes = paste0(\"L_\", 0:time.points), Ynodes = \"Y\",                      regimes = regimes, summary.measures = summary.measures,                      working.msm = \"Y ~ time.on.treatment + I(time.on.treatment^2)\") #> Qform not specified, using defaults: #> formula for L_2: #> Q.kplus1 ~ L_0 + L_1 + A_1 #> formula for L_3: #> Q.kplus1 ~ L_0 + L_1 + A_1 + L_2 + A_2 #> formula for L_4: #> Q.kplus1 ~ L_0 + L_1 + A_1 + L_2 + A_2 + L_3 + A_3 #> formula for L_5: #> Q.kplus1 ~ L_0 + L_1 + A_1 + L_2 + A_2 + L_3 + A_3 + L_4 + A_4 #> formula for Y: #> Q.kplus1 ~ L_0 + L_1 + A_1 + L_2 + A_2 + L_3 + A_3 + L_4 + A_4 +     L_5 + A_5 #>  #> gform not specified, using defaults: #> formula for A_1: #> A_1 ~ L_0 + L_1 #> formula for A_2: #> A_2 ~ L_0 + L_1 + A_1 + L_2 #> formula for A_3: #> A_3 ~ L_0 + L_1 + A_1 + L_2 + A_2 + L_3 #> formula for A_4: #> A_4 ~ L_0 + L_1 + A_1 + L_2 + A_2 + L_3 + A_3 + L_4 #> formula for A_5: #> A_5 ~ L_0 + L_1 + A_1 + L_2 + A_2 + L_3 + A_3 + L_4 + A_4 + L_5 #>  #> Estimate of time to completion: 7 to 43 minutes summary(result1) #> Estimator:  tmle  #>                        Estimate Std. Error  CI 2.5% CI 97.5%  p-value     #> (Intercept)            -0.14060    0.13310 -0.40146    0.120 0.290810     #> time.on.treatment       0.38277    0.11148  0.16428    0.601 0.000596 *** #> I(time.on.treatment^2) -0.03578    0.02194 -0.07879    0.007 0.102924     #> --- #> Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1 summary(result2) #> Estimator:  tmle  #>                        Estimate Std. Error  CI 2.5% CI 97.5% p-value    #> (Intercept)            -0.14060    0.18040 -0.49418    0.213 0.43578    #> time.on.treatment       0.38277    0.14435  0.09984    0.666 0.00801 ** #> I(time.on.treatment^2) -0.03578    0.02727 -0.08924    0.018 0.18951    #> --- #> Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1 at.least.3 <- summary.measures[, \"time.on.treatment\", 1] >= 3 regimes.3 <- regimes[, , at.least.3] summary.measures.3 <- summary.measures[at.least.3, , , drop = F] dim(regimes.3) #> [1] 5000    5   16 summary.measures.3 #> , , 1 #>  #>       time.on.treatment #>  [1,]                 3 #>  [2,]                 3 #>  [3,]                 3 #>  [4,]                 3 #>  [5,]                 4 #>  [6,]                 3 #>  [7,]                 3 #>  [8,]                 3 #>  [9,]                 4 #> [10,]                 3 #> [11,]                 3 #> [12,]                 4 #> [13,]                 3 #> [14,]                 4 #> [15,]                 4 #> [16,]                 5  result <- ltmleMSM(data, Anodes = paste0(\"A_\", 1:time.points),                     Lnodes = paste0(\"L_\", 0:time.points),                     Ynodes = \"Y\", regimes = regimes.3,                     summary.measures = summary.measures.3,                     working.msm = \"Y ~ time.on.treatment + I(time.on.treatment^2)\") #> Qform not specified, using defaults: #> formula for L_2: #> Q.kplus1 ~ L_0 + L_1 + A_1 #> formula for L_3: #> Q.kplus1 ~ L_0 + L_1 + A_1 + L_2 + A_2 #> formula for L_4: #> Q.kplus1 ~ L_0 + L_1 + A_1 + L_2 + A_2 + L_3 + A_3 #> formula for L_5: #> Q.kplus1 ~ L_0 + L_1 + A_1 + L_2 + A_2 + L_3 + A_3 + L_4 + A_4 #> formula for Y: #> Q.kplus1 ~ L_0 + L_1 + A_1 + L_2 + A_2 + L_3 + A_3 + L_4 + A_4 +     L_5 + A_5 #>  #> gform not specified, using defaults: #> formula for A_1: #> A_1 ~ L_0 + L_1 #> formula for A_2: #> A_2 ~ L_0 + L_1 + A_1 + L_2 #> formula for A_3: #> A_3 ~ L_0 + L_1 + A_1 + L_2 + A_2 + L_3 #> formula for A_4: #> A_4 ~ L_0 + L_1 + A_1 + L_2 + A_2 + L_3 + A_3 + L_4 #> formula for A_5: #> A_5 ~ L_0 + L_1 + A_1 + L_2 + A_2 + L_3 + A_3 + L_4 + A_4 + L_5 #>  #> Estimate of time to completion: 4 to 20 minutes summary(result) #> Estimator:  tmle  #>                        Estimate Std. Error CI 2.5% CI 97.5% p-value    #> (Intercept)             -4.8265     2.0784 -8.9001   -0.753 0.02022 *  #> time.on.treatment        2.9730     1.1300  0.7582    5.188 0.00852 ** #> I(time.on.treatment^2)  -0.3810     0.1489 -0.6729   -0.089 0.01051 *  #> --- #> Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1"},{"path":"http://joshuaschwab.github.io/ltmle/articles/a03_msm.html","id":"marginal-structural-models-msms---switching-time-example---multiple-regimes-and-outcomes","dir":"Articles","previous_headings":"","what":"Marginal Structural Models (MSMs) - Switching time example - Multiple regimes and outcomes","title":"Marginal Structural Models - ltmleMSM","text":"Given data 3 time points switches 1 stays 1. want know death varies function gender, time indicator whether patient’s intended regime switch time. Note working.msm includes time switch.time, columns summary.measures; working.msm also includes male, ok baseline covariate (comes /C/L/Y nodes). msm.weights just example. also 200x3x4 array NULL (weights), \"empirical\" (default). regimes can also specified list rule functions rule function applied row data returns numeric vector length Anodes. result.regimes: Suppose interested pooling result Y1 Y3. interested result Y3. time now constant working.msm, let’s remove .","code":"data(sampleDataForLtmleMSM) head(sampleDataForLtmleMSM$data, 20) #>    male age CD4_0 A0 Y1 CD4_1 A1 Y2 CD4_2 A2 Y3 #> 1     1  33   347  0  0   349  0  0   315  0  0 #> 2     0  18   277  0  0   302  0  0   300  0  0 #> 3     1  33   419  0  0   423  0  0   462  0  0 #> 4     1  35   318  1  0   358  1  0   413  1  0 #> 5     0  27   145  0  0   134  1  1    NA NA  1 #> 6     1  27   320  0  0   332  0  0   347  1  0 #> 7     1  35   220  0  0   241  0  0   216  1  0 #> 8     0  31   184  0  0   202  1  0   230  1  0 #> 9     0  35   289  0  0   302  0  0   290  0  0 #> 10    0  30   295  1  0   312  1  0   340  1  0 #> 11    0  31   300  1  0   394  1  0   467  1  0 #> 12    0  30   300  0  0   331  0  0   320  0  0 #> 13    0  25   276  0  1    NA NA  1    NA NA  1 #> 14    1  26   242  1  0   280  1  0   307  1  0 #> 15    0  21   238  1  0   345  1  0   379  1  0 #> 16    1  30   304  0  0   258  0  0   287  0  0 #> 17    0  30   271  1  0   297  1  0   324  1  0 #> 18    1  27   296  0  0   305  0  0   306  0  0 #> 19    1  33   217  1  0   242  1  0   267  1  0 #> 20    1  25   337  0  0   360  0  0   390  0  0 dim(sampleDataForLtmleMSM$regimes) #> [1] 200   3   4 sampleDataForLtmleMSM$regimes[1:5, , ] #> , , 1 #>  #>      [,1] [,2] [,3] #> [1,]    1    1    1 #> [2,]    1    1    1 #> [3,]    1    1    1 #> [4,]    1    1    1 #> [5,]    1    1    1 #>  #> , , 2 #>  #>      [,1] [,2] [,3] #> [1,]    0    1    1 #> [2,]    0    1    1 #> [3,]    0    1    1 #> [4,]    0    1    1 #> [5,]    0    1    1 #>  #> , , 3 #>  #>      [,1] [,2] [,3] #> [1,]    0    0    1 #> [2,]    0    0    1 #> [3,]    0    0    1 #> [4,]    0    0    1 #> [5,]    0    0    1 #>  #> , , 4 #>  #>      [,1] [,2] [,3] #> [1,]    0    0    0 #> [2,]    0    0    0 #> [3,]    0    0    0 #> [4,]    0    0    0 #> [5,]    0    0    0 sampleDataForLtmleMSM$summary.measures #> , , 1 #>  #>      switch.time time #> [1,]           0    1 #> [2,]           1    1 #> [3,]           2    1 #> [4,]           3    1 #>  #> , , 2 #>  #>      switch.time time #> [1,]           0    2 #> [2,]           1    2 #> [3,]           2    2 #> [4,]           3    2 #>  #> , , 3 #>  #>      switch.time time #> [1,]           0    3 #> [2,]           1    3 #> [3,]           2    3 #> [4,]           3    3 Anodes <- c(\"A0\", \"A1\", \"A2\") Lnodes <- c(\"CD4_1\", \"CD4_2\") Ynodes <- c(\"Y1\", \"Y2\", \"Y3\") msm.weights <- matrix(1:12, nrow=4, ncol=3) result.regimes <- ltmleMSM(sampleDataForLtmleMSM$data, Anodes=Anodes,                     Lnodes=Lnodes, Ynodes=Ynodes,                     survivalOutcome=TRUE,                    regimes=sampleDataForLtmleMSM$regimes,                     summary.measures=sampleDataForLtmleMSM$summary.measures,                    final.Ynodes=Ynodes,                     working.msm=\"Y ~ male + time + pmax(time - switch.time, 0)\",                     msm.weights=msm.weights, estimate.time=FALSE) #> Qform not specified, using defaults: #> formula for Y1: #> Q.kplus1 ~ male + age + CD4_0 + A0 #> formula for Y2: #> Q.kplus1 ~ male + age + CD4_0 + A0 + CD4_1 + A1 #> formula for Y3: #> Q.kplus1 ~ male + age + CD4_0 + A0 + CD4_1 + A1 + CD4_2 + A2 #>  #> gform not specified, using defaults: #> formula for A0: #> A0 ~ male + age + CD4_0 #> formula for A1: #> A1 ~ male + age + CD4_0 + A0 + CD4_1 #> formula for A2: #> A2 ~ male + age + CD4_0 + A0 + CD4_1 + A1 + CD4_2 #>  print(summary(result.regimes)) #> Estimator:  tmle  #>                             Estimate Std. Error CI 2.5% CI 97.5%  p-value     #> (Intercept)                  -3.4059     0.6545 -4.6886   -2.123 1.95e-07 *** #> male                         -0.3802     0.5305 -1.4198    0.660  0.47360     #> time                          0.7241     0.2602  0.2141    1.234  0.00539 **  #> pmax(time - switch.time, 0)  -0.4717     0.2019 -0.8675   -0.076  0.01948 *   #> --- #> Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1 regimesList <- list(function(row) c(1,1,1),                      function(row) c(0,1,1),                      function(row) c(0,0,1),                      function(row) c(0,0,0)) result.regList <- ltmleMSM(sampleDataForLtmleMSM$data, Anodes=Anodes,                     Lnodes=Lnodes, Ynodes=Ynodes,                     survivalOutcome=TRUE, regimes=regimesList,                     summary.measures=sampleDataForLtmleMSM$summary.measures,                    final.Ynodes=Ynodes,                     working.msm=\"Y ~ male + time + pmax(time - switch.time, 0)\",                     msm.weights=msm.weights, estimate.time=FALSE) #> Qform not specified, using defaults: #> formula for Y1: #> Q.kplus1 ~ male + age + CD4_0 + A0 #> formula for Y2: #> Q.kplus1 ~ male + age + CD4_0 + A0 + CD4_1 + A1 #> formula for Y3: #> Q.kplus1 ~ male + age + CD4_0 + A0 + CD4_1 + A1 + CD4_2 + A2 #>  #> gform not specified, using defaults: #> formula for A0: #> A0 ~ male + age + CD4_0 #> formula for A1: #> A1 ~ male + age + CD4_0 + A0 + CD4_1 #> formula for A2: #> A2 ~ male + age + CD4_0 + A0 + CD4_1 + A1 + CD4_2 #> print(summary(result.regList))          #> Estimator:  tmle  #>                             Estimate Std. Error CI 2.5% CI 97.5%  p-value     #> (Intercept)                  -3.4059     0.6545 -4.6886   -2.123 1.95e-07 *** #> male                         -0.3802     0.5305 -1.4198    0.660  0.47360     #> time                          0.7241     0.2602  0.2141    1.234  0.00539 **  #> pmax(time - switch.time, 0)  -0.4717     0.2019 -0.8675   -0.076  0.01948 *   #> --- #> Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1 result <- ltmleMSM(sampleDataForLtmleMSM$data, Anodes=Anodes,                     Lnodes=Lnodes, Ynodes=Ynodes,                     survivalOutcome=TRUE,                    regimes=sampleDataForLtmleMSM$regimes,                     summary.measures=sampleDataForLtmleMSM$summary.measures[, , c(1, 3)],                    final.Ynodes=c(\"Y1\", \"Y3\"),                     working.msm=\"Y ~ male + time + pmax(time - switch.time, 0)\",                     estimate.time=FALSE) #> Qform not specified, using defaults: #> formula for Y1: #> Q.kplus1 ~ male + age + CD4_0 + A0 #> formula for Y2: #> Q.kplus1 ~ male + age + CD4_0 + A0 + CD4_1 + A1 #> formula for Y3: #> Q.kplus1 ~ male + age + CD4_0 + A0 + CD4_1 + A1 + CD4_2 + A2 #>  #> gform not specified, using defaults: #> formula for A0: #> A0 ~ male + age + CD4_0 #> formula for A1: #> A1 ~ male + age + CD4_0 + A0 + CD4_1 #> formula for A2: #> A2 ~ male + age + CD4_0 + A0 + CD4_1 + A1 + CD4_2 #>  summary(result) #> Estimator:  tmle  #>                             Estimate Std. Error CI 2.5% CI 97.5%  p-value     #> (Intercept)                  -3.8891     0.5532 -4.9733   -2.805 2.06e-12 *** #> male                          0.2256     0.5144 -0.7826    1.234 0.660969     #> time                          0.7826     0.2314  0.3291    1.236 0.000718 *** #> pmax(time - switch.time, 0)  -0.4331     0.2018 -0.8287   -0.038 0.031874 *   #> --- #> Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1 result <- ltmleMSM(sampleDataForLtmleMSM$data, Anodes=Anodes,                      Lnodes=Lnodes, Ynodes=Ynodes,                      survivalOutcome=TRUE,                     regimes=sampleDataForLtmleMSM$regimes,                      summary.measures=sampleDataForLtmleMSM$summary.measures[, , 3],                     final.Ynodes=\"Y3\",                      working.msm=\"Y ~ male + switch.time\",                      estimate.time=FALSE) #> Qform not specified, using defaults: #> formula for Y1: #> Q.kplus1 ~ male + age + CD4_0 + A0 #> formula for Y2: #> Q.kplus1 ~ male + age + CD4_0 + A0 + CD4_1 + A1 #> formula for Y3: #> Q.kplus1 ~ male + age + CD4_0 + A0 + CD4_1 + A1 + CD4_2 + A2 #>  #> gform not specified, using defaults: #> formula for A0: #> A0 ~ male + age + CD4_0 #> formula for A1: #> A1 ~ male + age + CD4_0 + A0 + CD4_1 #> formula for A2: #> A2 ~ male + age + CD4_0 + A0 + CD4_1 + A1 + CD4_2 #>  summary(result) #> Estimator:  tmle  #>             Estimate Std. Error  CI 2.5% CI 97.5%  p-value     #> (Intercept) -2.81063    0.46529 -3.72257   -1.899 1.54e-09 *** #> male         0.07357    0.53635 -0.97766    1.125   0.8909     #> switch.time  0.45362    0.19384  0.07370    0.834   0.0193 *   #> --- #> Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1"},{"path":"http://joshuaschwab.github.io/ltmle/articles/a03_msm.html","id":"marginal-structural-models-msms---dynamic-treatment","dir":"Articles","previous_headings":"","what":"Marginal Structural Models (MSMs) - Dynamic Treatment","title":"Marginal Structural Models - ltmleMSM","text":"example two treatment nodes one outcome: W A1 L A2 Y W normally distributed L continuous (0, 1). interested treatments A1 set either 0 1 A2 set dynamically. treatment A2 indexed theta 0 1. \\(L > theta\\), set A2 1, otherwise set A2 0. function can used generate observed data (abar = NULL) generate counterfactual truth (abar list a1 theta): Set regimes summary.measures: Let’s compare true coefficients MSM. First find true value \\(E[Y_{a1, theta}]\\) 5 values theta. Fit working MSM true values \\(E[Y_{a1, theta}]\\). estimated MSM coefficients close true MSM coefficients.","code":"GenerateData <- function(n, abar = NULL) {   W <- rnorm(n)   if (is.null(abar)) {     A1 <- rexpit(W)   } else {     A1 <- abar$a1   }   L <- plogis(rnorm(n) + 0.3 * W + 0.5 * A1)   if (is.null(abar)) {     A2 <- rexpit(-0.5 * W + A1 - 0.6 * L)   } else {     A2 <- as.integer(L > abar$theta)   }   Y <- rexpit(-2 + W + A1 + L + 2 * A2)   if (is.null(abar)) {     return(data.frame(W, A1, L, A2, Y))   } else {     return(mean(Y))   } } set.seed(11) n <- 10000 data <- GenerateData(n) regimes <- array(dim = c(n, 2, 10)) #n x num.Anodes x num.regimes theta.set <- seq(0, 1, length.out = 5) summary.measures <- array(theta.set, dim = c(10, 2, 1)) colnames(summary.measures) <- c(\"a1\", \"theta\") cnt <- 0 for (a1 in 0:1) {   for (theta.index in 1:5) {     cnt <- cnt + 1     regimes[, 1, cnt] <- a1     regimes[, 2, cnt] <- data$L > theta.set[theta.index]     summary.measures[cnt, , 1] <- c(a1, theta.set[theta.index])   } } summary.measures #> , , 1 #>  #>       a1 theta #>  [1,]  0  0.00 #>  [2,]  0  0.25 #>  [3,]  0  0.50 #>  [4,]  0  0.75 #>  [5,]  0  1.00 #>  [6,]  1  0.00 #>  [7,]  1  0.25 #>  [8,]  1  0.50 #>  [9,]  1  0.75 #> [10,]  1  1.00 head(data, 3) #>             W A1          L A2 Y #> 1 -0.59103110  1 0.77137613  1 1 #> 2  0.02659437  0 0.47561600  1 0 #> 3 -1.51655310  0 0.08392365  1 0 regimes[1:3, , ] #> , , 1 #>  #>      [,1] [,2] #> [1,]    0    1 #> [2,]    0    1 #> [3,]    0    1 #>  #> , , 2 #>  #>      [,1] [,2] #> [1,]    0    1 #> [2,]    0    1 #> [3,]    0    0 #>  #> , , 3 #>  #>      [,1] [,2] #> [1,]    0    1 #> [2,]    0    0 #> [3,]    0    0 #>  #> , , 4 #>  #>      [,1] [,2] #> [1,]    0    1 #> [2,]    0    0 #> [3,]    0    0 #>  #> , , 5 #>  #>      [,1] [,2] #> [1,]    0    0 #> [2,]    0    0 #> [3,]    0    0 #>  #> , , 6 #>  #>      [,1] [,2] #> [1,]    1    1 #> [2,]    1    1 #> [3,]    1    1 #>  #> , , 7 #>  #>      [,1] [,2] #> [1,]    1    1 #> [2,]    1    1 #> [3,]    1    0 #>  #> , , 8 #>  #>      [,1] [,2] #> [1,]    1    1 #> [2,]    1    0 #> [3,]    1    0 #>  #> , , 9 #>  #>      [,1] [,2] #> [1,]    1    1 #> [2,]    1    0 #> [3,]    1    0 #>  #> , , 10 #>  #>      [,1] [,2] #> [1,]    1    0 #> [2,]    1    0 #> [3,]    1    0 working.msm <- \"Y ~ a1*theta\" summary(ltmleMSM(data, Anodes = c(\"A1\", \"A2\"), Lnodes = \"L\", Ynodes = \"Y\",                regimes = regimes, summary.measures = summary.measures,                working.msm = working.msm)) #> Qform not specified, using defaults: #> formula for L: #> Q.kplus1 ~ W + A1 #> formula for Y: #> Q.kplus1 ~ W + A1 + L + A2 #>  #> gform not specified, using defaults: #> formula for A1: #> A1 ~ W #> formula for A2: #> A2 ~ W + A1 + L #>  #> Estimate of time to completion: 3 to 7 minutes #> Estimator:  tmle  #>              Estimate Std. Error   CI 2.5% CI 97.5% p-value     #> (Intercept)  0.531670   0.050294  0.433095    0.630  <2e-16 *** #> a1           1.039499   0.074409  0.893660    1.185  <2e-16 *** #> theta       -1.817514   0.071766 -1.958172   -1.677  <2e-16 *** #> a1:theta    -0.006772   0.110068 -0.222502    0.209   0.951     #> --- #> Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1 truth <- rep(NA_real_, 10) cnt <- 0 for (a1 in 0:1) {   for (theta.index in 1:5) {     cnt <- cnt + 1     truth[cnt] <- GenerateData(n = 1e6,                      abar = list(a1 = a1, theta = theta.set[theta.index]))   } } m.true <- glm(working.msm,                data = data.frame(Y = truth, summary.measures[, , 1]),                family = \"quasibinomial\") m.true #>  #> Call:  glm(formula = working.msm, family = \"quasibinomial\", data = data.frame(Y = truth,  #>     summary.measures[, , 1])) #>  #> Coefficients: #> (Intercept)           a1        theta     a1:theta   #>     0.51141      0.96385     -1.75721     -0.03266   #>  #> Degrees of Freedom: 9 Total (i.e. Null);  6 Residual #> Null Deviance:       1.342  #> Residual Deviance: 0.02332   AIC: NA"},{"path":"http://joshuaschwab.github.io/ltmle/articles/a04_deterministic-functions.html","id":"deterministic-g-function","dir":"Articles","previous_headings":"","what":"deterministic.g.function","title":"Deterministic Functions","text":"Time ordering data W, C1, L1, A1, Y1, C2, L2, A2, Y2 True value E[Y_(1,1,1,1)] (expected value Y setting C1, A1, C2, A2 1) approximately 0.413. A1 known always 1 L1 < -2, 1 probability 0.1 L1 > 2 A2 known always 1 A1 1 can incorporate knowledge using deterministic.g.function. Generate data: Without considering deterministic knowledge A1 A2: Now use deterministic.g.function include deterministic knowledge A1 A2:","code":"set.seed(123) rexpit <- function(x) rbinom(n=length(x), size=1, prob=plogis(x)) n <- 1000 ua <- rep(TRUE, n)   #ua = uncensored and alive L1 <- A1 <- Y1 <- C2.binary <- L2 <- A2 <- Y2 <- rep(NA_real_, n) W <- rnorm(n)  C1 <- BinaryToCensoring(is.uncensored=rexpit(2 + W)) ua <- ua & C1 == \"uncensored\" L1[ua] <- rnorm(n)[ua] + W[ua] A1[ua] <- rexpit(L1[ua]) A1[ua & L1 < -2] <- 1 A1[ua & L1 >  2] <- rbinom(n, size=1, prob=0.1)[ua & L1 >  2] Y1[ua] <- rexpit((W + L1 - A1)[ua]) ua <- ua & !Y1  C2.binary[ua] <- rexpit((1 + 0.7 * L1 - A1)[ua]) C2 <- BinaryToCensoring(is.uncensored=C2.binary) ua <- ua & C2 == \"uncensored\" L2[ua] <- (0.5 * L1 - 0.9 * A1 + rnorm(n))[ua] A2[ua] <- rexpit((0.5 * L1 + 0.8 * L2)[ua]) | A1[ua] Y2[ua] <- rexpit((0.7 * L1 + L2 - 0.8 * A1 - A2)[ua]) Y2[Y1 == 1] <- 1  # if a patient dies at time 1, record death at time 2 as well data <- data.frame(W, C1, L1, A1, Y1, C2, L2, A2, Y2) result <- ltmle(data, Anodes=c(\"A1\",\"A2\"), Cnodes=c(\"C1\", \"C2\"),                  Lnodes=c(\"L1\", \"L2\"), Ynodes=c(\"Y1\", \"Y2\"), abar=c(1, 1),                  survivalOutcome=TRUE) #> Qform not specified, using defaults: #> formula for L1: #> Q.kplus1 ~ W #> formula for Y1: #> Q.kplus1 ~ W + L1 + A1 #> formula for L2: #> Q.kplus1 ~ W + L1 + A1 #> formula for Y2: #> Q.kplus1 ~ W + L1 + A1 + L2 + A2 #>  #> gform not specified, using defaults: #> formula for C1: #> C1 ~ W #> formula for A1: #> A1 ~ W + L1 #> formula for C2: #> C2 ~ W + L1 + A1 #> formula for A2: #> A2 ~ W + L1 + A1 + L2 #>  #> Estimate of time to completion: < 1 minute summary(result)  #> Estimator:  tmle  #> Call: #> ltmle(data = data, Anodes = c(\"A1\", \"A2\"), Cnodes = c(\"C1\", \"C2\"),  #>     Lnodes = c(\"L1\", \"L2\"), Ynodes = c(\"Y1\", \"Y2\"), survivalOutcome = TRUE,  #>     abar = c(1, 1)) #>  #>    Parameter Estimate:  0.42358  #>     Estimated Std Err:  0.022199  #>               p-value:  <2e-16  #>     95% Conf Interval: (0.38007, 0.46709) deterministic.g.function <- function(data, current.node, nodes) {   if (names(data)[current.node] == \"A1\") {     det <- (data$L1 < -2 | data$L1 > 2) & !is.na(data$L1)     prob1 <- ((data$L1 < -2) * 1 + (data$L1 > 2) * 0.1)[det]   } else if (names(data)[current.node] == \"A2\") {     det <- data$A1 == 1 & !is.na(data$A1)     prob1 <- 1   } else if (names(data[current.node]) %in% c(\"C1\", \"C2\")){     return(NULL)  #this returns the default of no deterministic links      #note that it is not necessary to specify that prior censoring indicates future censoring   } else {     stop(\"unexpected current.node\")   }   return(list(is.deterministic=det, prob1=prob1))   } result <- ltmle(data, Anodes=c(\"A1\",\"A2\"), Cnodes=c(\"C1\", \"C2\"),                  Lnodes=c(\"L1\", \"L2\"), Ynodes=c(\"Y1\", \"Y2\"), abar=c(1, 1),                  survivalOutcome=TRUE, deterministic.g.function = deterministic.g.function) #> Qform not specified, using defaults: #> formula for L1: #> Q.kplus1 ~ W #> formula for Y1: #> Q.kplus1 ~ W + L1 + A1 #> formula for L2: #> Q.kplus1 ~ W + L1 + A1 #> formula for Y2: #> Q.kplus1 ~ W + L1 + A1 + L2 + A2 #>  #> gform not specified, using defaults: #> formula for C1: #> C1 ~ W #> formula for A1: #> A1 ~ W + L1 #> formula for C2: #> C2 ~ W + L1 + A1 #> formula for A2: #> A2 ~ W + L1 + A1 + L2 #>  #> Estimate of time to completion: < 1 minute summary(result)  #> Estimator:  tmle  #> Call: #> ltmle(data = data, Anodes = c(\"A1\", \"A2\"), Cnodes = c(\"C1\", \"C2\"),  #>     Lnodes = c(\"L1\", \"L2\"), Ynodes = c(\"Y1\", \"Y2\"), survivalOutcome = TRUE,  #>     abar = c(1, 1), deterministic.g.function = deterministic.g.function) #>  #>    Parameter Estimate:  0.42013  #>     Estimated Std Err:  0.026763  #>               p-value:  <2e-16  #>     95% Conf Interval: (0.36768, 0.47259)"},{"path":"http://joshuaschwab.github.io/ltmle/articles/a04_deterministic-functions.html","id":"deterministic-q-function","dir":"Articles","previous_headings":"","what":"deterministic.Q.function","title":"Deterministic Functions","text":"example, L2 positive, patient leaves study consider final outcome 0. W -> A1 -> Y1 -> L2 -> A2 -> Y2 Scenario 1: patients don’t change treatment leaving study; leave A2 NA Specify Q deterministically 0 L2 history current Q regression L2 > 0 necessary specify Q deterministically 1 Y1 1; automatic. Also note det.Q.fun doesn’t condition called..estimate.g g also set deterministically L2 > 0. Scenario 2: treatment can still change patient leaves study","code":"n <- 1000 L2 <- A2 <- Y2 <- as.numeric(rep(NA, n)) W <- rnorm(n) A1 <- rexpit(W) Y1 <- rexpit(W - A1) alive <- Y1 == 0 L2[alive] <- (0.5 * W - 0.9 * A1 + rnorm(n))[alive] completed.study <- alive & L2 > 0 A2[alive & !completed.study] <- rexpit((0.5 * W + 0.8 * L2)[alive & !completed.study])  Y2[alive & !completed.study] <- rexpit((L2 - 0.8 * A1 - A2)[alive & !completed.study]) Y2[alive & completed.study] <- 0 Y2[!alive] <- 1  # if a patient dies at time 1, record death at time 2 as well data <- data.frame(W, A1, Y1, L2, A2, Y2) det.Q.fun.1 <- function(data, current.node, nodes, called.from.estimate.g) {   L2.index <- which(names(data) == \"L2\")   stopifnot(length(L2.index) == 1)   L2.in.history <- L2.index < current.node   if (! L2.in.history) return(NULL)      is.deterministic <- data$L2 > 0 & !is.na(data$L2)   return(list(is.deterministic=is.deterministic, Q.value=0)) }  result.scenario1 <- ltmle(data, Anodes=c(\"A1\",\"A2\"), Lnodes=\"L2\", Ynodes=c(\"Y1\", \"Y2\"), abar=c(1, 1),    SL.library=NULL, estimate.time=FALSE, deterministic.Q.function=det.Q.fun.1, survivalOutcome=TRUE) #> Qform not specified, using defaults: #> formula for Y1: #> Q.kplus1 ~ W + A1 #> formula for Y2: #> Q.kplus1 ~ W + A1 + L2 + A2 #>  #> gform not specified, using defaults: #> formula for A1: #> A1 ~ W #> formula for A2: #> A2 ~ W + A1 + L2 #>  summary(result.scenario1) #> Estimator:  tmle  #> Call: #> ltmle(data = data, Anodes = c(\"A1\", \"A2\"), Lnodes = \"L2\", Ynodes = c(\"Y1\",  #>     \"Y2\"), survivalOutcome = TRUE, abar = c(1, 1), SL.library = NULL,  #>     estimate.time = FALSE, deterministic.Q.function = det.Q.fun.1) #>  #>    Parameter Estimate:  0.33534  #>     Estimated Std Err:  0.02463  #>               p-value:  <2e-16  #>     95% Conf Interval: (0.28707, 0.38361) A2[alive] <- rexpit((0.5 * W + 0.8 * L2)[alive])  #patients can change treatment after leaving study Y2[alive & !completed.study] <- rexpit((L2 - 0.8 * A1 - A2)[alive & !completed.study]) Y2[alive & completed.study] <- 0 Y2[!alive] <- 1  # if a patient dies at time 1, record death at time 2 as well data <- data.frame(W, A1, Y1, L2, A2, Y2)  det.Q.fun.2 <- function(data, current.node, nodes, called.from.estimate.g) {   #there is no deterministic information when calculating g - treatment may still change   if (called.from.estimate.g) return(NULL)        L2.index <- which(names(data) == \"L2\")   stopifnot(length(L2.index) == 1)   L2.in.history <- L2.index < current.node   if (! L2.in.history) return(NULL)      is.deterministic <- data$L2 > 0 & !is.na(data$L2)   return(list(is.deterministic=is.deterministic, Q.value=0)) }  result.scenario2 <- ltmle(data, Anodes=c(\"A1\",\"A2\"), Lnodes=\"L2\", Ynodes=c(\"Y1\", \"Y2\"), abar=c(1, 1),   SL.library=NULL, estimate.time=FALSE, deterministic.Q.function=det.Q.fun.2, survivalOutcome=TRUE) #> Qform not specified, using defaults: #> formula for Y1: #> Q.kplus1 ~ W + A1 #> formula for Y2: #> Q.kplus1 ~ W + A1 + L2 + A2 #>  #> gform not specified, using defaults: #> formula for A1: #> A1 ~ W #> formula for A2: #> A2 ~ W + A1 + L2 #>  #> Warning in CheckForVarianceWarning(inputs, g.ratio): Variance estimate is based #> on influence curve only, which may be significantly anticonservative because #> your data appears to contain positivity violations. Robust variance estimate is #> not currently available with deterministic.Q.function but this will be #> addressed in a future release. summary(result.scenario2) #> Estimator:  tmle  #> Call: #> ltmle(data = data, Anodes = c(\"A1\", \"A2\"), Lnodes = \"L2\", Ynodes = c(\"Y1\",  #>     \"Y2\"), survivalOutcome = TRUE, abar = c(1, 1), SL.library = NULL,  #>     estimate.time = FALSE, deterministic.Q.function = det.Q.fun.2) #>  #>    Parameter Estimate:  0.3223  #>     Estimated Std Err:  0.023814  #>               p-value:  <2e-16  #>     95% Conf Interval: (0.27562, 0.36897)"},{"path":"http://joshuaschwab.github.io/ltmle/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Joshua Schwab. Author, maintainer. Samuel Lendle. Author. Maya Petersen. Author. Mark van der Laan. Author. Susan Gruber. Contributor.","code":""},{"path":"http://joshuaschwab.github.io/ltmle/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Lendle SD, Schwab J, Petersen ML, van der Laan MJ (2017). “ltmle: R Package Implementing Targeted Minimum Loss-Based Estimation Longitudinal Data.” Journal Statistical Software, 81(1), 1–21. doi:10.18637/jss.v081.i01.","code":"@Article{,   title = {{ltmle}: An {R} Package Implementing Targeted Minimum Loss-Based Estimation for Longitudinal Data},   author = {Samuel D. Lendle and Joshua Schwab and Maya L. Petersen and Mark J. {van der Laan}},   journal = {Journal of Statistical Software},   year = {2017},   volume = {81},   number = {1},   pages = {1--21},   doi = {10.18637/jss.v081.i01}, }"},{"path":"http://joshuaschwab.github.io/ltmle/index.html","id":"ltmle","dir":"","previous_headings":"","what":"Longitudinal Targeted Maximum Likelihood Estimation","title":"Longitudinal Targeted Maximum Likelihood Estimation","text":"Longitudinal Targeted Maximum Likelihood Estimation package see  examples","code":""},{"path":"http://joshuaschwab.github.io/ltmle/reference/BinaryToCensoring.html","id":null,"dir":"Reference","previous_headings":"","what":"BinaryToCensoring — BinaryToCensoring","title":"BinaryToCensoring — BinaryToCensoring","text":"Helper function creating censoring columns factors.","code":""},{"path":"http://joshuaschwab.github.io/ltmle/reference/BinaryToCensoring.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"BinaryToCensoring — BinaryToCensoring","text":"","code":"BinaryToCensoring(is.censored, is.uncensored)"},{"path":"http://joshuaschwab.github.io/ltmle/reference/BinaryToCensoring.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"BinaryToCensoring — BinaryToCensoring","text":".censored binary vector: 0=uncensored, 1=censored .uncensored binary vector: 0=censored, 1=uncensored","code":""},{"path":"http://joshuaschwab.github.io/ltmle/reference/BinaryToCensoring.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"BinaryToCensoring — BinaryToCensoring","text":"object class \"factor\" levels \"censored\" \"uncensored\"","code":""},{"path":"http://joshuaschwab.github.io/ltmle/reference/BinaryToCensoring.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"BinaryToCensoring — BinaryToCensoring","text":"Exactly one .censored .uncensored must specified named argument.  elements input vector must 0, 1, NA","code":""},{"path":[]},{"path":"http://joshuaschwab.github.io/ltmle/reference/BinaryToCensoring.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"BinaryToCensoring — BinaryToCensoring","text":"Joshua Schwab jschwab77@berkeley.edu","code":""},{"path":"http://joshuaschwab.github.io/ltmle/reference/BinaryToCensoring.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"BinaryToCensoring — BinaryToCensoring","text":"","code":"BinaryToCensoring(is.censored=c(0, 1, 1, 0, NA)) #> [1] uncensored censored   censored   uncensored <NA>       #> Levels: censored uncensored  BinaryToCensoring(is.uncensored=c(1, 0, 0, 1, NA))   #the same #> [1] uncensored censored   censored   uncensored <NA>       #> Levels: censored uncensored    if (FALSE) {  BinaryToCensoring(c(0, 1))   #error because the input must be named  }"},{"path":"http://joshuaschwab.github.io/ltmle/reference/deterministic.g.function_template.html","id":null,"dir":"Reference","previous_headings":"","what":"Deterministic g/Q functions - examples and templates — deterministic.g.function_template","title":"Deterministic g/Q functions - examples and templates — deterministic.g.function_template","text":"Template deterministic.g.function  argument ltmle ltmleMSM.","code":""},{"path":"http://joshuaschwab.github.io/ltmle/reference/deterministic.g.function_template.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Deterministic g/Q functions - examples and templates — deterministic.g.function_template","text":"","code":"deterministic.g.function_template(data, current.node, nodes)  deterministic.Q.function_template(   data,   current.node,   nodes,   called.from.estimate.g )"},{"path":"http://joshuaschwab.github.io/ltmle/reference/deterministic.g.function_template.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Deterministic g/Q functions - examples and templates — deterministic.g.function_template","text":"data 'data' data.frame passed ltmle ltmleMSM current.node column index data corresponding C node (g) L Y node (Q) nodes list column indicies, components: Anodes (treatment) C Cnodes (censoring) L Lnodes (time-varying covariates) Y Ynodes (events) AC Anodes Cnodes combined sorted LY Lnodes Ynodes combined, sorted, \"blocks\" removed - see ltmle called..estimate.g TRUE FALSE - function called called..estimate.g=TRUE estimation g called..estimate.g=FALSE estimation Q.","code":""},{"path":"http://joshuaschwab.github.io/ltmle/reference/deterministic.g.function_template.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Deterministic g/Q functions - examples and templates — deterministic.g.function_template","text":"deterministic.g.function return list components: .deterministic vector logicals, length=nrow(data) prob1 probability data[.deterministic, current.node] == 1, vector length 1 length((.deterministic)) deterministic.Q.function return list components: .deterministic vector logicals, length=nrow(data) Q.value iterated expectation final Y, vector length 1 length((.deterministic)) NOTE: Q.value component used required called..estimate.g TRUE","code":""},{"path":"http://joshuaschwab.github.io/ltmle/reference/deterministic.g.function_template.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Deterministic g/Q functions - examples and templates — deterministic.g.function_template","text":"MaintainTreatment MaintainControl two commonly used deterministic.g.functions. intended use templates user copy paste function arguments body fill required sections. run -. Note comments functions saved. Versions comments may found Examples section . MaintainTreatment MaintainControl may passed -deterministic.g.function argument ltmle ltmleMSM Note censoring nodes data may passed binaries converted preferred format factors levels \"censored\" \"uncensored\" deterministic functions called.  Also note nodes may passed ltmle either names nodes numerical column indicies, converted numerical indicies deterministic functions called.  survivalFunction argument ltmle ltmleMSM TRUE, package automatically assumes Y jumps 1, future Y nodes stay 1 treatment change. necessary specify deterministic functions.","code":""},{"path":"http://joshuaschwab.github.io/ltmle/reference/deterministic.g.function_template.html","id":"functions","dir":"Reference","previous_headings":"","what":"Functions","title":"Deterministic g/Q functions - examples and templates — deterministic.g.function_template","text":"deterministic.Q.function_template(): Template deterministic.Q.function  argument ltmle ltmleMSM.","code":""},{"path":[]},{"path":"http://joshuaschwab.github.io/ltmle/reference/deterministic.g.function_template.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Deterministic g/Q functions - examples and templates — deterministic.g.function_template","text":"Joshua Schwab jschwab77@berkeley.edu","code":""},{"path":"http://joshuaschwab.github.io/ltmle/reference/deterministic.g.function_template.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Deterministic g/Q functions - examples and templates — deterministic.g.function_template","text":"","code":"# Show template for a deterministic.g.function (comments will not be # shown, see below for comments) deterministic.g.function_template #> function (data, current.node, nodes)  #> { #>     is.deterministic <- stop(\"replace me!\") #>     prob1 <- stop(\"replace me!\") #>     return(list(is.deterministic = is.deterministic, prob1 = prob1)) #> } #> <bytecode: 0x56235beeb7f0> #> <environment: namespace:ltmle>  # Show template for a deterministic.Q.function (comments will not be # shown, see below for comments) deterministic.Q.function_template #> function (data, current.node, nodes, called.from.estimate.g)  #> { #>     is.deterministic <- stop(\"replace me!\") #>     Q.value <- stop(\"replace me!\") #>     return(list(is.deterministic = is.deterministic, Q.value = Q.value)) #> } #> <bytecode: 0x56235bf7a5a0> #> <environment: namespace:ltmle>  # Use MaintainTreatment set.seed(1) rexpit <- function(x) rbinom(n = length(x), size = 1, prob = plogis(x)) n <- 100 W <- rnorm(n) A1 <- rexpit(W) A2 <- as.numeric(rexpit(W) | A1)  #treatment at time 1 implies treatment at time 2 Y <- rexpit(W + A1 + A2 + rnorm(n)) data <- data.frame(W, A1, A2, Y)  result <- ltmle(data, Anodes = c(\"A1\", \"A2\"), Ynodes = \"Y\", abar = c(1, 1),      deterministic.g.function = MaintainTreatment) #> Qform not specified, using defaults: #> formula for Y: #> Q.kplus1 ~ W + A1 + A2 #>  #> gform not specified, using defaults: #> formula for A1: #> A1 ~ W #> formula for A2: #> A2 ~ W + A1 #>  #> Estimate of time to completion: < 1 minute  # deterministic.g.function_template with comments:  deterministic.g.function_template <- function(data, current.node, nodes) {     # data: the 'data' data.frame passed to ltmle/ltmleMSM current.node: the     # column index of data corresponding to the A or C node (see     # is.deterministic below) nodes: list of column indicies, components: A,     # C, L, Y, AC (Anodes and Cnodes combined and sorted), LY (Lnodes and     # Ynodes combined, sorted, 'blocks' removed - see ?ltmle) Note that nodes     # may be passed to ltmle as either the names of nodes or numerical column     # indicies, but they are all converted to numerical indicies before     # deterministic.g.function is called          # deterministic.g.function will be called at all Anodes and Cnodes     # return(NULL) is equivalent to return(list(is.deterministic=rep(FALSE,     # nrow(data)), prob1=numeric(0)))          # define is.deterministic here: vector of logicals, length=nrow(data)     # define prob1 here: the probability that data[is.deterministic,     # current.node] == 1, vector of length 1 or     # length(which(is.deterministic))     is.deterministic <- stop(\"replace me!\")     prob1 <- stop(\"replace me!\")     return(list(is.deterministic = is.deterministic, prob1 = prob1)) }  # deterministic.Q.function_template with comments:  deterministic.Q.function_template <- function(data, current.node, nodes,      called.from.estimate.g) {     # data: the 'data' data.frame passed to ltmle/ltmleMSM current.node: the     # column index of data corresponding to the A or C node (see     # is.deterministic below) nodes: list of column indicies, components: A,     # C, L, Y, AC (Anodes and Cnodes combined and sorted), LY (Lnodes and     # Ynodes combined, sorted, 'blocks' removed - see ?ltmle)     # called.from.estimate.g: TRUE or FALSE - your function will be called     # with called.from.estimate.g=TRUE during estimation of g and     # called.from.estimate.g=FALSE during estimation of Q. During estimation     # of g, only the is.deterministic element of the return list will be     # used.  Note that nodes may be passed to ltmle as either the names of     # nodes or numerical column indicies, but they are all converted to     # numerical indicies before deterministic.Q.function is called          # It is not necessary to specify that deterministic Y events (Y==1)     # indicate a deterministic Q value of 1; this is automatic      # if the survivalFunction input to ltmle/ltmleMSM is TRUE.     # deterministic.Q.function will be called at all Lnodes and Ynodes (after     # removing 'blocks') and Anodes and Cnodes (see called.from.estimate.g     # above) return(NULL) is equivalent to     # return(list(is.deterministic=rep(FALSE, nrow(data)),     # Q.value=numeric(0)))          # define is.deterministic here: vector of logicals, length=nrow(data)     # define Q.value here: the iterated expectation of the final Y, vector of     # length 1 or length(which(is.deterministic))     is.deterministic <- stop(\"replace me!\")     Q.value <- stop(\"replace me!\")     return(list(is.deterministic = is.deterministic, Q.value = Q.value)) }"},{"path":"http://joshuaschwab.github.io/ltmle/reference/sampleDataForLtmleMSM.html","id":null,"dir":"Reference","previous_headings":"","what":"Sample data, regimes, and summary measures — sampleDataForLtmleMSM","title":"Sample data, regimes, and summary measures — sampleDataForLtmleMSM","text":"Sample data use ltmleMSM. Data: n=1000: male age CD4_1 A1 Y1 CD4_2 A2 Y2 CD4_3 A3 Y3 A1..A3 treatment nodes, Y1..Y3 death, CD4_1..CD4_3 time varying covariates. interested static regimes patient switches time. summary.measures, switch.time first time 1 (4 never switch), time horizon.","code":""},{"path":"http://joshuaschwab.github.io/ltmle/reference/sampleDataForLtmleMSM.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Sample data, regimes, and summary measures — sampleDataForLtmleMSM","text":"List three components: data, regimes, summary.measures","code":""},{"path":"http://joshuaschwab.github.io/ltmle/reference/sampleDataForLtmleMSM.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"Sample data, regimes, and summary measures — sampleDataForLtmleMSM","text":"simulated data","code":""},{"path":"http://joshuaschwab.github.io/ltmle/reference/sampleDataForLtmleMSM.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Sample data, regimes, and summary measures — sampleDataForLtmleMSM","text":"regimes: 200 x 3 x 4 [n x numACnodes x numRegimes] summary.measures: 4 x 2 x 3 [numRegimes x numSummaryMeasures x numFinalYnodes]","code":""},{"path":"http://joshuaschwab.github.io/ltmle/reference/sampleDataForLtmleMSM.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Sample data, regimes, and summary measures — sampleDataForLtmleMSM","text":"","code":"data(sampleDataForLtmleMSM)"},{"path":"http://joshuaschwab.github.io/ltmle/reference/summary.ltmle.html","id":null,"dir":"Reference","previous_headings":"","what":"Get standard error, p-value, and confidence interval for one ltmle object\nSummarizing results from Longitudinal Targeted Maximum Likelihood Estimation\n(ltmle) — summary.ltmle","title":"Get standard error, p-value, and confidence interval for one ltmle object\nSummarizing results from Longitudinal Targeted Maximum Likelihood Estimation\n(ltmle) — summary.ltmle","text":"functions methods class ltmle summary.ltmle objects.","code":""},{"path":"http://joshuaschwab.github.io/ltmle/reference/summary.ltmle.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get standard error, p-value, and confidence interval for one ltmle object\nSummarizing results from Longitudinal Targeted Maximum Likelihood Estimation\n(ltmle) — summary.ltmle","text":"","code":"# S3 method for ltmle summary(object, estimator = ifelse(object$gcomp, \"gcomp\", \"tmle\"), ...)  # S3 method for ltmleEffectMeasures summary(object, estimator = ifelse(object$gcomp, \"gcomp\", \"tmle\"), ...)  # S3 method for ltmleMSM summary(object, estimator = ifelse(object$gcomp, \"gcomp\", \"tmle\"), ...)  # S3 method for summary.ltmleMSM print(   x,   digits = max(3, getOption(\"digits\") - 3),   signif.stars = getOption(\"show.signif.stars\"),   ... )  # S3 method for summary.ltmle print(x, ...)  # S3 method for ltmleEffectMeasures print(x, ...)  # S3 method for summary.ltmleEffectMeasures print(x, ...)  # S3 method for ltmleMSM print(x, ...)  # S3 method for ltmle print(x, ...)"},{"path":"http://joshuaschwab.github.io/ltmle/reference/summary.ltmle.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get standard error, p-value, and confidence interval for one ltmle object\nSummarizing results from Longitudinal Targeted Maximum Likelihood Estimation\n(ltmle) — summary.ltmle","text":"object object class \"ltmle\" \"ltmleMSM\" \"ltmleEffectMeasures\", usually result call ltmle ltmleMSM. estimator character; one \"tmle\", \"iptw\", \"gcomp\". estimator get effect measures. \"tmle\" valid iff original ltmle/ltmleMSM call used gcomp=FALSE. \"gcomp\" valid iff original ltmle/ltmleMSM call used gcomp=TRUE ... arguments passed methods. x object class \"summary.ltmle\" \"summary.ltmleMSM\" \"ltmleEffectMeasures\", usually result call summary.ltmle summary.ltmleMSM. digits number significant digits use printing. signif.stars logical. TRUE, significance stars printed coefficient.","code":""},{"path":"http://joshuaschwab.github.io/ltmle/reference/summary.ltmle.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get standard error, p-value, and confidence interval for one ltmle object\nSummarizing results from Longitudinal Targeted Maximum Likelihood Estimation\n(ltmle) — summary.ltmle","text":"summary.ltmle returns object class \"summary.ltmle\", list components treatment list components summarizing estimate object estimate - parameter estimate \\(E[Y_d]\\) std.dev - estimated standard deviation parameter p.value - two-sided p-value CI - vector length 2 95 percent confidence interval  call matched call ltmle object estimator estimator input argument variance.estimate.ratio ratio TMLE based variance estimate influence curve based variance estimate summary.ltmleEffectMeasures returns object class \"summary.ltmleEffectMeasures\", list components summary.ltmle , also includes: effect.measures list components, components treatment summary.ltmle treatment - corresponds first list abar (rule) passed ltmle control - corresponds second list abar (rule) passed ltmle ATE - average treatment effect RR - relative risk - odds ratio  summary.ltmleMSM returns object class \"summary.ltmleMSM\", matrix rows MSM parameter columns point estimate, standard error, 2.5percent confidence interval, 97.5percent confidence interval, p-value.","code":""},{"path":"http://joshuaschwab.github.io/ltmle/reference/summary.ltmle.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Get standard error, p-value, and confidence interval for one ltmle object\nSummarizing results from Longitudinal Targeted Maximum Likelihood Estimation\n(ltmle) — summary.ltmle","text":"summary.ltmle returns parameter value estimator, estimated variance, 95 percent confidence interval, p-value. summary.ltmleEffectMeasures returns additive treatment effect two objects abar list passed ltmle. Relative risk, odds ratio also returned, along variance, confidence interval, p-value . summary.ltmleMSM returns matrix MSM parameter estimates.","code":""},{"path":[]},{"path":"http://joshuaschwab.github.io/ltmle/reference/summary.ltmle.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Get standard error, p-value, and confidence interval for one ltmle object\nSummarizing results from Longitudinal Targeted Maximum Likelihood Estimation\n(ltmle) — summary.ltmle","text":"","code":"rexpit <- function(x) rbinom(n = length(x), size = 1, prob = plogis(x))  # Compare the expected outcomes under two counterfactual plans: Treatment plan: # set A1 to 1 if W > 0, set A2 to 1 if W > 1.5, always set A3 to 1 Control plan: # always set A1, A2, and A3 to 0 W <- rnorm(1000) A1 <- rexpit(W) A2 <- rexpit(W + 2 * A1) A3 <- rexpit(2 * A1 - A2) Y <- rexpit(W - A1 + 0.5 * A2 + 2 * A3) data <- data.frame(W, A1, A2, A3, Y) treatment <- cbind(W > 0, W > 1.5, 1) control <- matrix(0, nrow = 1000, ncol = 3) result <- ltmle(data, Anodes = c(\"A1\", \"A2\", \"A3\"), Ynodes = \"Y\", abar = list(treatment,     control)) #> Qform not specified, using defaults: #> formula for Y: #> Q.kplus1 ~ W + A1 + A2 + A3 #>  #> gform not specified, using defaults: #> formula for A1: #> A1 ~ W #> formula for A2: #> A2 ~ W + A1 #> formula for A3: #> A3 ~ W + A1 + A2 #>  #> Estimate of time to completion: < 1 minute print(summary(result)) #> Estimator:  tmle  #> Call: #> ltmle(data = data, Anodes = c(\"A1\", \"A2\", \"A3\"), Ynodes = \"Y\",  #>     abar = list(treatment, control)) #>  #> Treatment Estimate: #>    Parameter Estimate:  0.83681  #>     Estimated Std Err:  0.038758  #>               p-value:  <2e-16  #>     95% Conf Interval: (0.76084, 0.91277)  #>  #> Control Estimate: #>    Parameter Estimate:  0.49693  #>     Estimated Std Err:  0.061101  #>               p-value:  4.1906e-16  #>     95% Conf Interval: (0.37717, 0.61669)  #>  #> Additive Treatment Effect: #>    Parameter Estimate:  0.33988  #>     Estimated Std Err:  0.072357  #>               p-value:  2.6374e-06  #>     95% Conf Interval: (0.19806, 0.48169)  #>  #> Relative Risk: #>    Parameter Estimate:  1.684  #>   Est Std Err log(RR):  0.13139  #>               p-value:  7.2983e-05  #>     95% Conf Interval: (1.3016, 2.1786)  #>  #> Odds Ratio: #>    Parameter Estimate:  5.1911  #>   Est Std Err log(OR):  0.37455  #>               p-value:  1.0972e-05  #>     95% Conf Interval: (2.4914, 10.816)  #>   ## For examples of summary.ltmle and summary.ltmleMSM, see example(ltmle)"}]
